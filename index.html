<!doctype html>
<html lang="es">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gespropiedad Avatar</title>
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
  <style>
    :root {
      --brand-primary: #1ca4af;
      --brand-secondary: #1c3768;
      --bg-dark: #0b0f14;
      --bg-card: #0f1621;
      --bg-input: #0a0e14;
      --border-color: #1f2a3a;
      --border-light: #2a3c54;
      --text-primary: #e6edf3;
      --text-muted: rgba(230, 237, 243, 0.6);
      --success: #22c55e;
      --error: #ef4444;
      --warning: #eab308;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, sans-serif;
      background: linear-gradient(135deg, var(--bg-dark) 0%, #1a1f2e 100%);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }

    /* ============================
       OVERLAY DE INICIO
       ============================ */
    .start-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, #0b0f14 0%, #131a24 50%, #0d1117 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      gap: 20px;
      padding: 24px;
    }

    .start-overlay.hidden {
      display: none;
    }

    .start-logo {
      width: 100px;
      height: auto;
      opacity: 0.9;
    }

    .start-overlay h1 {
      font-size: 1.6rem;
      margin: 0;
      color: #fff;
      font-weight: 600;
      letter-spacing: -0.02em;
      text-align: center;
    }

    .start-overlay p {
      font-size: 0.95rem;
      color: var(--text-muted);
      margin: 0;
      text-align: center;
      max-width: 320px;
      line-height: 1.5;
    }

    .start-buttons {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 12px;
      width: 100%;
      max-width: 300px;
    }

    .start-btn {
      background: linear-gradient(135deg, var(--brand-primary) 0%, var(--brand-secondary) 100%);
      color: white;
      border: none;
      padding: 14px 28px;
      font-size: 0.95rem;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.25s ease;
      box-shadow: 0 4px 20px rgba(28, 164, 175, 0.25);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      width: 100%;
    }

    .start-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 28px rgba(28, 164, 175, 0.35);
    }

    .start-btn:active {
      transform: translateY(0);
    }

    .start-btn.secondary {
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      box-shadow: none;
    }

    .start-btn.secondary:hover {
      background: rgba(255, 255, 255, 0.12);
      box-shadow: none;
    }

    .start-btn i {
      width: 18px;
      height: 18px;
      flex-shrink: 0;
    }

    /* ============================
       MODO PRESENTACIÓN
       ============================ */
    body.presentation-mode {
      background: #000;
      padding: 0;
    }

    body.presentation-mode .stage {
      display: none;
    }

    .presentation-container {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #000;
      z-index: 9999;
      align-items: center;
      justify-content: center;
    }

    body.presentation-mode .presentation-container {
      display: flex;
    }

    .presentation-avatar {
      opacity: 0;
      transform: scale(0.92);
      transition: opacity 1.8s ease-out, transform 1.8s ease-out;
      position: relative;
    }

    .presentation-avatar.visible {
      opacity: 1;
      transform: scale(1);
    }

    .presentation-avatar.fading-out {
      opacity: 0;
      transform: scale(0.92);
      transition: opacity 2.5s ease-in, transform 2.5s ease-in;
    }

    .presentation-avatar .pres-rive-wrap {
      width: 100vmin;
      height: 100vmin;
      max-width: 700px;
      max-height: 700px;
      display: grid;
      place-items: center;
    }

    .presentation-avatar #presentationCanvas {
      width: 100%;
      height: 100%;
    }

    /* Logo de fondo grande y visible */
    .presentation-container::before {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 105vh;
      height: 105vh;
      opacity: 0;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 226.1 219.1'%3E%3Cdefs%3E%3ClinearGradient id='a' x1='56' y1='178.7' x2='56' y2='0' gradientUnits='userSpaceOnUse'%3E%3Cstop offset='0' stop-color='%231ca4af'/%3E%3Cstop offset='1' stop-color='%231c3768'/%3E%3C/linearGradient%3E%3ClinearGradient id='b' x1='139.2' y1='53.5' x2='232.6' y2='215.2' href='%23a'/%3E%3C/defs%3E%3Cpolygon fill='url(%23a)' points='0 0 73.6 111 26.2 178.7 65.6 178.7 111.9 109.9 41.8 0 0 0'/%3E%3Cpolygon fill='url(%23b)' points='194.6 45.6 150.2 111 226 219 186.7 219 111.9 109.9 152.9 45.6 194.6 45.6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: center;
      background-size: contain;
      pointer-events: none;
      z-index: 0;
      transition: opacity 1.8s ease-out;
    }

    .presentation-container.show-logo::before {
      opacity: 0.33;
    }

    .presentation-subtitle {
      position: fixed;
      bottom: 6%;
      left: 50%;
      transform: translateX(-50%);
      max-width: 85%;
      text-align: center;
      font-size: clamp(1rem, 2.2vw, 1.4rem);
      line-height: 1.6;
      color: rgba(255, 255, 255, 0.95);
      text-shadow: 0 2px 16px rgba(0, 0, 0, 0.9);
      opacity: 0;
      transition: opacity 0.4s ease;
      z-index: 10001;
      padding: 14px 24px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 10px;
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .presentation-subtitle.visible {
      opacity: 1;
    }

    .exit-presentation-btn {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.12);
      color: white;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      cursor: pointer;
      z-index: 10002;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.3s, background 0.2s;
    }

    .exit-presentation-btn:hover {
      background: rgba(255, 255, 255, 0.15);
      opacity: 1 !important;
    }

    .exit-presentation-btn i {
      width: 20px;
      height: 20px;
    }

    .presentation-container:hover .exit-presentation-btn {
      opacity: 0.4;
    }

    /* ============================
       PANEL PRINCIPAL
       ============================ */
    .stage {
      width: 100%;
      max-width: 900px;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, .35);
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
      padding: 28px;
      align-items: center;
    }

    @media (max-width: 800px) {
      .stage {
        grid-template-columns: 1fr;
        gap: 20px;
        padding: 20px;
      }

      .avatar {
        order: 1;
      }

      .panel {
        order: 2;
      }
    }

    @media (max-width: 480px) {
      body {
        padding: 8px;
      }

      .stage {
        border-radius: 16px;
        padding: 16px;
        gap: 16px;
      }

      .rive-wrap {
        width: 220px !important;
        height: 220px !important;
      }

      #riveCanvas {
        width: 200px !important;
        height: 200px !important;
      }

      .bubble {
        min-height: 70px !important;
        font-size: 15px !important;
      }

      .btn-row {
        flex-direction: column;
      }

      .btn {
        width: 100%;
      }
    }

    /* Avatar */
    .avatar {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 260px;
      position: relative;
    }

    .rive-wrap {
      width: 280px;
      height: 280px;
      display: grid;
      place-items: center;
      border-radius: 20px;
      background: radial-gradient(circle at 30% 30%, #1a2535, #0d121b 70%);
      border: 1px solid #223146;
      box-shadow:
        inset 0 0 0 1px rgba(255, 255, 255, 0.03),
        0 8px 32px rgba(0, 0, 0, 0.3);
      overflow: hidden;
      position: relative;
    }

    #riveCanvas {
      width: 260px;
      height: 260px;
    }

    /* CSS Fallback */
    .css-avatar {
      display: none;
      place-items: center;
    }

    .head {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #2b3b52, #111823 70%);
      position: relative;
      border: 1px solid #243247;
      animation: breathe 5.5s ease-in-out infinite;
    }

    @keyframes breathe {

      0%,
      100% {
        transform: translateY(0);
      }

      50% {
        transform: translateY(-2px);
      }
    }

    .eye {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--text-primary);
      position: absolute;
      top: 65px;
      overflow: hidden;
    }

    .eye.left {
      left: 55px;
    }

    .eye.right {
      right: 55px;
    }

    .eye::after {
      content: "";
      position: absolute;
      inset: 0;
      background: var(--bg-card);
      transform: translateY(-120%);
      animation: blink 6s infinite;
    }

    @keyframes blink {

      0%,
      92%,
      100% {
        transform: translateY(-120%);
      }

      94%,
      96% {
        transform: translateY(0%);
      }
    }

    .pupil {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background: var(--bg-dark);
      position: absolute;
      top: 6px;
      left: 6px;
    }

    .mouth {
      width: 60px;
      height: 12px;
      background: var(--text-primary);
      border-radius: 0 0 12px 12px;
      position: absolute;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%) scaleY(0.2);
      transform-origin: center top;
      transition: transform 40ms linear;
    }

    /* Panel */
    .panel {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .status-bar {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      background: var(--bg-input);
      border-radius: 10px;
      border: 1px solid var(--border-color);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #666;
      flex-shrink: 0;
    }

    .status-dot.ok {
      background: var(--success);
    }

    .status-dot.error {
      background: var(--error);
    }

    .status-dot.loading {
      background: var(--warning);
      animation: pulse 1s infinite;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.4;
      }
    }

    .status-text {
      font-size: 13px;
      color: var(--text-muted);
      flex: 1;
    }

    .debug {
      font-size: 10px;
      color: var(--text-muted);
      font-family: 'SF Mono', Monaco, Consolas, monospace;
      max-height: 60px;
      overflow-y: auto;
      background: var(--bg-input);
      padding: 10px 12px;
      border-radius: 8px;
      white-space: pre-wrap;
      word-break: break-all;
      line-height: 1.4;
      border: 1px solid var(--border-color);
    }

    .bubble {
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 14px 16px;
      min-height: 90px;
      max-height: 130px;
      overflow-y: auto;
      font-size: 15px;
      line-height: 1.5;
      color: var(--text-primary);
    }

    /* Buttons */
    .btn-row {
      display: flex;
      gap: 10px;
    }

    .btn {
      background: rgba(255, 255, 255, 0.06);
      color: var(--text-primary);
      border: 1px solid var(--border-light);
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 500;
      font-size: 13px;
      transition: all 0.15s;
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .btn:active {
      transform: scale(0.97);
    }

    .btn i {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
    }

    .btn.primary {
      background: linear-gradient(135deg, var(--brand-primary) 0%, var(--brand-secondary) 100%);
      border: none;
      box-shadow: 0 2px 12px rgba(28, 164, 175, 0.2);
    }

    .btn.primary:hover {
      box-shadow: 0 4px 16px rgba(28, 164, 175, 0.3);
    }

    .btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* Settings */
    .settings-section {
      background: var(--bg-input);
      border-radius: 10px;
      padding: 12px 14px;
      border: 1px solid var(--border-color);
    }

    .settings-section label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 8px;
    }

    .settings-section label i {
      width: 14px;
      height: 14px;
    }

    .voice-select {
      background: var(--bg-dark);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 13px;
      width: 100%;
    }

    .voice-select:focus {
      outline: none;
      border-color: var(--brand-primary);
    }

    /* Fullscreen button */
    .fullscreen-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.1);
      width: 32px;
      height: 32px;
      padding: 0;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.2s, background 0.2s;
      color: white;
    }

    .fullscreen-btn i {
      width: 16px;
      height: 16px;
    }

    .rive-wrap:hover .fullscreen-btn {
      opacity: 0.7;
    }

    .fullscreen-btn:hover {
      opacity: 1 !important;
      background: rgba(0, 0, 0, 0.6);
    }

    /* Rive fullscreen mode */
    .rive-wrap.fullscreen {
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      width: 100vw !important;
      height: 100vh !important;
      max-width: none !important;
      border-radius: 0 !important;
      z-index: 9999;
      background: #000;
    }

    .rive-wrap.fullscreen #riveCanvas {
      width: 100vmin !important;
      height: 100vmin !important;
    }

    .rive-wrap.fullscreen .fullscreen-btn {
      top: 16px;
      right: 16px;
      width: 40px;
      height: 40px;
      opacity: 0.5;
    }
  </style>
</head>

<body>
  <!-- Overlay de inicio -->
  <div class="start-overlay" id="startOverlay">
    <svg class="start-logo" viewBox="0 0 226.1 219.1" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <linearGradient id="grad1" x1="56" y1="178.7" x2="56" y2="0" gradientUnits="userSpaceOnUse">
          <stop offset="0" stop-color="#1ca4af" />
          <stop offset="1" stop-color="#1c3768" />
        </linearGradient>
        <linearGradient id="grad2" x1="139.2" y1="53.5" x2="232.6" y2="215.2" gradientUnits="userSpaceOnUse">
          <stop offset="0" stop-color="#1ca4af" />
          <stop offset="1" stop-color="#1c3768" />
        </linearGradient>
      </defs>
      <polygon fill="url(#grad1)" points="0 0 73.6 111 26.2 178.7 65.6 178.7 111.9 109.9 41.8 0 0 0" />
      <polygon fill="url(#grad2)" points="194.6 45.6 150.2 111 226 219 186.7 219 111.9 109.9 152.9 45.6 194.6 45.6" />
    </svg>
    <h1>Asistente Virtual</h1>
    <p>Selecciona cómo quieres interactuar con el avatar</p>
    <div class="start-buttons">
      <button class="start-btn" id="startPresentationBtn">
        <i data-lucide="tv"></i>
        Modo Presentación
      </button>
      <button class="start-btn secondary" id="startNormalBtn">
        <i data-lucide="settings-2"></i>
        Panel de Control
      </button>
    </div>
  </div>

  <!-- Contenedor presentación fullscreen -->
  <div class="presentation-container" id="presentationContainer">
    <button class="exit-presentation-btn" id="exitPresentationBtn" title="Salir (ESC)">
      <i data-lucide="x"></i>
    </button>
    <div class="presentation-avatar" id="presentationAvatar">
      <div class="pres-rive-wrap">
        <canvas id="presentationCanvas" width="800" height="800"></canvas>
      </div>
    </div>
    <div class="presentation-subtitle" id="presentationSubtitle"></div>
  </div>

  <!-- Panel principal -->
  <div class="stage">
    <div class="avatar">
      <div class="rive-wrap" id="riveWrap">
        <button class="fullscreen-btn" id="fullscreenBtn" title="Pantalla completa">
          <i data-lucide="maximize-2"></i>
        </button>
        <canvas id="riveCanvas" width="600" height="600"></canvas>
      </div>
      <div class="css-avatar" id="cssAvatar">
        <div class="head">
          <div class="eye left">
            <div class="pupil"></div>
          </div>
          <div class="eye right">
            <div class="pupil"></div>
          </div>
          <div class="mouth" id="cssMouth"></div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="status-bar">
        <span class="status-dot loading" id="statusDot"></span>
        <span class="status-text" id="statusText">Inicializando...</span>
      </div>

      <div class="debug" id="debug"></div>

      <div class="bubble" id="bubble">Listo para recibir eventos.</div>

      <div class="btn-row">
        <button class="btn primary" id="testTalkBtn">
          <i data-lucide="play"></i>
          Test
        </button>
        <button class="btn" id="idleBtn">
          <i data-lucide="pause"></i>
          Detener
        </button>
      </div>

      <div class="btn-row">
        <button class="btn primary" id="enterPresentationBtn">
          <i data-lucide="tv"></i>
          Modo Presentación
        </button>
      </div>

      <div class="settings-section">
        <label>
          <i data-lucide="volume-2"></i>
          Voz TTS
        </label>
        <select id="voiceSelect" class="voice-select">
          <option value="">Cargando voces...</option>
        </select>
      </div>
    </div>
  </div>

  <script type="module">
    // ===========================================
    // CONFIGURACIÓN
    // ===========================================
    const CONFIG = {
      ELEVENLABS_API_KEY: "sk_ed00c8630aeb0240abba435c3f0a4afcd6794a79c0d1aba6",
      ELEVENLABS_VOICE_ID: "uU1QvfOppdkePeLtG9pI",
      ELEVENLABS_MODEL: "eleven_multilingual_v2",
      BACKEND_HOST: "hogar-avatar-api.conexiatec.com",
      RIVE_FILE: "./avatar.riv",
      STATE_MACHINE: "State Machine",
      USE_BROWSER_TTS_FALLBACK: true,
      PRESENTATION_START_ID: "intro_1",
      PRESENTATION_END_ID: "despedida_1",

      // Duración de cada pausa de labios (ms)
      PAUSE_DURATION: 500,
    };

    // ===========================================
    // BANCO DE AUDIOS CON TIMESTAMPS MANUALES
    // 
    // pauses: Array de timestamps (en milisegundos) donde 
    //         los labios deben cerrarse durante PAUSE_DURATION ms
    // 
    // Ejemplo: pauses: [1500, 3200, 5800]
    //          - En el ms 1500, cierra labios 500ms
    //          - En el ms 3200, cierra labios 500ms
    //          - En el ms 5800, cierra labios 500ms
    //
    // TIP: Reproduce el audio y anota los segundos donde hay pausas,
    //      luego multiplica por 1000 para obtener milisegundos.
    //      Ejemplo: pausa en 2.3 segundos → 2300
    // ===========================================
    const AUDIO_BANK = {
      "intro_1": {
        text: "Hola a todos. Perdonad mi entrada… estaba esperando. Y he pensado: 'igual os habíais olvidado de mí'.",
        audio: "./audio/intro_1.mp3",
        // Duración: 6.58s
        pauses: [
          770,   // después de "Hola a todos."
          2240,  // después de "estaba esperando."
          4420,  // después de "Y he pensado:"
        ]
      },
      "que_es_1": {
        text: "Buenas noches a todos. Y sí, es cierto: no duermo… no pido vacaciones… y los lunes no me afectan. Pero prometo ser simpática igualmente. Me presento: soy la nueva IA de Gestpropiedad. Vengo a echar una mano en tres frentes. Primero, con los clientes. Cuando la oficina cierre, me quedo de guardia para que ningún cliente se quede sin respuesta. Segundo, en la web. Ayudaré a entender mejor cada vivienda y a guiar a cada cliente hasta el asesor correcto. Y tercero, el más importante: vosotros. Os ayudaré a encontrar la información que necesitéis en segundos, y a responder con más claridad… sin quitaros vuestro estilo.",
        audio: "./audio/que_es_1.mp3",
        // Duración: 40.80s
        pauses: [
          1050,  // después de "Buenas noches a todos."
          4770,  // después de "no duermo…"
          6910,  // después de "no pido vacaciones…"
          10260, // después de "ser simpática igualmente."
          11780, // después de "Me presento:"
          14760, // después de "Gestpropiedad."
          18300, // después de "Primero, con los clientes."
          23740, // después de "sin respuesta."
          26200, // después de "Segundo, en la web."
          29030, // después de "asesor correcto."
          31620, // después de "Y tercero, el más importante:"
          36240, // después de "en segundos,"
          38170, // después de "más claridad…"
        ]
      },
      "aprendizaje_1": {
        text: "No es todo, esto es solo el principio. Hoy es, literalmente, mi nacimiento. A partir de ahora iré aprendiendo cada día: de las consultas… de cómo trabajáis… de lo que necesitan los clientes… y de los datos que me ha proporcionado el equipo. Cuanto más se me use, mejor podré ayudar… y en más ámbitos. Prometo crecer rápido… y sin adolescencia rebelde.",
        audio: "./audio/aprendizaje_1.mp3",
        // Duración: 24.69s
        pauses: [
          1805,  // después de "esto es solo el principio."
          5440,  // después de "mi nacimiento."
          8560,  // después de "cada día:"
          11420, // después de "de cómo trabajáis…"
          13870, // después de "de lo que necesitan los clientes…"
          16530, // después de "el equipo."
          18730, // después de "y en más ámbitos."
          22500, // después de "crecer rápido…"
        ]
      },
      "despedida_1": {
        text: "Exacto. No tengo nombre. De momento soy 'la IA de Gestpropiedad'… y suena frío, poco personal... Como vamos a trabajar juntos, me gustaría que fuerais vosotros, mi equipo, quienes elijáis mi nombre esta noche. Yo me despido aquí y os dejo con Alejandro para que os explique las opciones. Para cuando vuelva… ya será con mi nombre oficial. Y tranquilos: ninguna opción es 'ChatPaco' ni 'BotManolo'... …de eso podéis estar seguros... Ha sido un placer saludaros por primera vez. Gracias, y nos vemos muy pronto.",
        audio: "./audio/despedida_1.mp3",
        // Duración: 35.60s
        pauses: [
          640,   // después de "Exacto."
          4560,  // después de "No tengo nombre."
          7050,  // después de "poco personal..."
          12820, // después de "esta noche."
          17540, // después de "las opciones."
          19490, // después de "Para cuando vuelva…"
          21070, // después de "nombre oficial."
          23100, // después de "Y tranquilos:"
          30250, // después de "estar seguros..."
          32820, // después de "primera vez."
        ]
      },
    };
    const AUDIO_BY_TEXT = {};

    // ===========================================
    // Importar Rive
    // ===========================================
    import RiveCanvas from "https://cdn.jsdelivr.net/npm/@rive-app/canvas@2.21.6/+esm";

    // ===========================================
    // DOM
    // ===========================================
    const $ = id => document.getElementById(id);
    const statusDot = $("statusDot");
    const statusText = $("statusText");
    const debugEl = $("debug");
    const bubbleEl = $("bubble");
    const riveWrap = $("riveWrap");
    const riveCanvas = $("riveCanvas");
    const cssAvatar = $("cssAvatar");
    const cssMouth = $("cssMouth");
    const voiceSelect = $("voiceSelect");
    const startOverlay = $("startOverlay");
    const startNormalBtn = $("startNormalBtn");
    const startPresentationBtn = $("startPresentationBtn");

    const presentationContainer = $("presentationContainer");
    const presentationAvatar = $("presentationAvatar");
    const presentationCanvas = $("presentationCanvas");
    const presentationSubtitle = $("presentationSubtitle");
    const exitPresentationBtn = $("exitPresentationBtn");
    const enterPresentationBtn = $("enterPresentationBtn");

    let isPresentationMode = false;
    let presentationRiveInstance = null;
    let presentationIsTalkingInput = null;
    let presentationVisemeIDInput = null;

    function setStatus(text, state = "loading") {
      statusText.textContent = text;
      statusDot.className = "status-dot " + state;
    }

    function log(msg) {
      console.log("[Avatar]", msg);
      const time = new Date().toLocaleTimeString("es", { hour12: false });
      debugEl.textContent = `[${time}] ${msg}\n` + debugEl.textContent.slice(0, 400);
    }

    // ===========================================
    // AUDIO UNLOCK
    // ===========================================
    async function unlockAudio() {
      try {
        const silentAudio = new Audio("data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2teleCAHQJnx+aCFNgRDmvz/mXoxBEaZ/P+YdywFR5r8/5d3KgZIm/z/lnkpB0mc/P+VeigISp38/5R7JwlLnfz/k3wmCkye/P+SfSULTZ/8/5F+JAxOoPz/kH8jDU+h/P+PgCIOUKL8/46BIQ9Ro/z/jYIfEFKk/P+MgyAQU6X8/4uEHxFUpvz/ioUeElWn/P+Jhh0TV6j8/4iHHBRYqfz/h4gcFVqq/P+GiRsWW6v8/4WKGhdcrPz/hIoZGF2t/P+DixgZXq78/4KMGB5fr/z/gY0XH2Cw/P+AjhYgYbH8/3+PFSFisfz/fpAUI2Oz/P99kRMkZLT8/3ySEiVltfz/e5MSJGW1");
        silentAudio.volume = 0.01;
        await silentAudio.play();
        silentAudio.pause();

        if (synth) {
          const u = new SpeechSynthesisUtterance("");
          u.volume = 0;
          synth.speak(u);
          synth.cancel();
        }

        log("Audio OK ✓");
        return true;
      } catch (e) {
        log("Audio error: " + e.message);
        return false;
      }
    }

    // Modo normal
    startNormalBtn.onclick = async () => {
      await unlockAudio();
      startOverlay.classList.add("hidden");
    };

    // Modo presentación desde overlay
    startPresentationBtn.onclick = async () => {
      await unlockAudio();
      startOverlay.classList.add("hidden");
      await enterPresentationMode();
    };

    // ===========================================
    // MODO PRESENTACIÓN
    // ===========================================
    async function enterPresentationMode() {
      log("→ Modo presentación");
      isPresentationMode = true;
      document.body.classList.add("presentation-mode");

      if (!presentationRiveInstance) {
        await initPresentationRive();
      }

      presentationAvatar.classList.remove("visible", "fading-out");
      presentationSubtitle.classList.remove("visible");
      presentationSubtitle.textContent = "";
    }

    function exitPresentationMode() {
      log("← Saliendo de presentación");
      isPresentationMode = false;
      document.body.classList.remove("presentation-mode");
      presentationAvatar.classList.remove("visible", "fading-out");
      presentationContainer.classList.remove("show-logo");
      presentationSubtitle.classList.remove("visible");
    }

    function showPresentationAvatar() {
      log("✨ Avatar apareciendo");
      presentationContainer.classList.add("show-logo");
      presentationAvatar.classList.remove("fading-out");
      presentationAvatar.classList.add("visible");
    }

    function hidePresentationAvatar() {
      log("✨ Avatar desapareciendo");
      presentationAvatar.classList.add("fading-out");
      presentationSubtitle.classList.remove("visible");

      setTimeout(() => {
        presentationContainer.classList.remove("show-logo");
        presentationAvatar.classList.remove("visible", "fading-out");
      }, 3000);
    }

    function showSubtitle(text) {
      if (!isPresentationMode) return;
      presentationSubtitle.textContent = text;
      presentationSubtitle.classList.add("visible");
    }

    function hideSubtitle() {
      presentationSubtitle.classList.remove("visible");
    }

    async function initPresentationRive() {
      log("Cargando Rive (presentación)...");

      const Rive = RiveCanvas.Rive || RiveCanvas.default || RiveCanvas;

      return new Promise((resolve) => {
        try {
          presentationRiveInstance = new Rive({
            src: CONFIG.RIVE_FILE,
            canvas: presentationCanvas,
            stateMachines: CONFIG.STATE_MACHINE,
            autoplay: true,
            onLoad: () => {
              setTimeout(() => {
                try {
                  const inputs = presentationRiveInstance.stateMachineInputs(CONFIG.STATE_MACHINE);
                  if (inputs && inputs.length > 0) {
                    inputs.forEach(input => {
                      if (input.name === "isTalking") presentationIsTalkingInput = input;
                      else if (input.name === "VisemeID") presentationVisemeIDInput = input;
                    });
                    log("✓ Rive presentación OK");
                  }
                  resolve();
                } catch (e) {
                  log("Error inputs: " + e.message);
                  resolve();
                }
              }, 100);
            },
            onLoadError: (err) => {
              log("Error Rive: " + err);
              resolve();
            }
          });
        } catch (e) {
          log("Error Rive: " + e.message);
          resolve();
        }
      });
    }

    exitPresentationBtn.onclick = exitPresentationMode;
    enterPresentationBtn.onclick = enterPresentationMode;

    // ===========================================
    // CSS Fallback
    // ===========================================
    function cssSetMouthOpen(value) {
      const scale = 0.2 + (value * 0.8);
      cssMouth.style.transform = `translateX(-50%) scaleY(${scale})`;
    }

    // ===========================================
    // TTS
    // ===========================================
    let synth = window.speechSynthesis;
    let voices = [];
    let selectedVoice = null;
    let currentUtterance = null;

    function loadVoices() {
      voices = synth.getVoices();
      const spanishVoices = voices.filter(v => v.lang.startsWith('es'));
      const otherVoices = voices.filter(v => !v.lang.startsWith('es'));
      const sortedVoices = [...spanishVoices, ...otherVoices];

      voiceSelect.innerHTML = '';

      if (sortedVoices.length === 0) {
        voiceSelect.innerHTML = '<option value="">Sin voces</option>';
        return;
      }

      sortedVoices.forEach((voice, i) => {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `${voice.name} (${voice.lang})`;
        if (voice.lang.startsWith('es') && !selectedVoice) {
          option.selected = true;
          selectedVoice = voice;
        }
        voiceSelect.appendChild(option);
      });

      if (!selectedVoice && sortedVoices.length > 0) {
        selectedVoice = sortedVoices[0];
        voiceSelect.selectedIndex = 0;
      }

      log("Voces: " + sortedVoices.length);
    }

    if (synth.onvoiceschanged !== undefined) {
      synth.onvoiceschanged = loadVoices;
    }
    loadVoices();

    voiceSelect.addEventListener('change', () => {
      const allVoices = synth.getVoices();
      const spanishVoices = allVoices.filter(v => v.lang.startsWith('es'));
      const otherVoices = allVoices.filter(v => !v.lang.startsWith('es'));
      const sortedVoices = [...spanishVoices, ...otherVoices];
      selectedVoice = sortedVoices[voiceSelect.value] || null;
    });

    function speak(text, audioId = null) {
      return new Promise(async (resolve) => {
        if (!text && !audioId) { resolve(); return; }

        if (audioId && AUDIO_BANK[audioId]) {
          const entry = AUDIO_BANK[audioId];
          log("Audio: " + audioId);
          bubbleEl.textContent = entry.text;
          if (isPresentationMode) showSubtitle(entry.text);
          try {
            // Pasar los timestamps de pausa al reproductor
            await playPrerecordedAudio(entry.audio, entry.pauses || []);
            resolve();
            return;
          } catch (e) {
            log("Error audio: " + e.message);
          }
        }

        if (text && AUDIO_BY_TEXT[text]) {
          try {
            await playPrerecordedAudio(AUDIO_BY_TEXT[text], []);
            resolve();
            return;
          } catch (e) { }
        }

        if (CONFIG.ELEVENLABS_API_KEY && text) {
          try {
            await speakWithElevenLabs(text);
            resolve();
            return;
          } catch (e) {
            log("ElevenLabs error: " + e.message);
            if (!CONFIG.USE_BROWSER_TTS_FALLBACK) {
              stopTalking();
              resolve();
              return;
            }
          }
        }

        if (!synth || !text) { resolve(); return; }

        synth.cancel();
        currentUtterance = new SpeechSynthesisUtterance(text);
        if (selectedVoice) currentUtterance.voice = selectedVoice;
        currentUtterance.lang = 'es-ES';

        currentUtterance.onstart = () => startTTSLipSync();
        currentUtterance.onend = () => { stopTalking(); resolve(); };
        currentUtterance.onerror = () => { stopTalking(); resolve(); };

        synth.speak(currentUtterance);
      });
    }

    // ===========================================
    // Audio Pregenerado con Timestamps de Pausa
    // ===========================================
    let prerecordedAudio = null;

    async function playPrerecordedAudio(audioUrl, pauseTimestamps = []) {
      return new Promise((resolve, reject) => {
        if (prerecordedAudio) {
          prerecordedAudio.pause();
          prerecordedAudio = null;
        }

        prerecordedAudio = new Audio(audioUrl);

        prerecordedAudio.onplay = () => {
          log("▶ Audio reproduciendo");
          // Iniciar lip-sync con los timestamps de pausa
          startLipSyncWithTimestamps(pauseTimestamps);
        };

        prerecordedAudio.onended = () => {
          log("⏹ Audio terminado");
          stopTalking();
          resolve();
        };

        prerecordedAudio.onerror = () => {
          stopTalking();
          reject(new Error("Audio error"));
        };

        prerecordedAudio.play().catch(reject);
      });
    }

    // ===========================================
    // ElevenLabs
    // ===========================================
    let elevenLabsAudio = null;

    async function speakWithElevenLabs(text) {
      log("ElevenLabs...");

      const response = await fetch(
        `https://api.elevenlabs.io/v1/text-to-speech/${CONFIG.ELEVENLABS_VOICE_ID}`,
        {
          method: "POST",
          headers: {
            "Accept": "audio/mpeg",
            "Content-Type": "application/json",
            "xi-api-key": CONFIG.ELEVENLABS_API_KEY,
          },
          body: JSON.stringify({
            text,
            model_id: CONFIG.ELEVENLABS_MODEL,
            voice_settings: { stability: 0.5, similarity_boost: 0.75 },
          }),
        }
      );

      if (!response.ok) throw new Error(`API ${response.status}`);

      const audioBlob = await response.blob();
      const audioUrl = URL.createObjectURL(audioBlob);

      return new Promise((resolve, reject) => {
        if (elevenLabsAudio) elevenLabsAudio.pause();

        elevenLabsAudio = new Audio(audioUrl);
        elevenLabsAudio.onplay = () => startTTSLipSync();
        elevenLabsAudio.onended = () => { stopTalking(); URL.revokeObjectURL(audioUrl); resolve(); };
        elevenLabsAudio.onerror = () => { stopTalking(); URL.revokeObjectURL(audioUrl); reject(); };
        elevenLabsAudio.play().catch(reject);
      });
    }

    function stopSpeaking() {
      if (synth) synth.cancel();
      if (elevenLabsAudio) { elevenLabsAudio.pause(); elevenLabsAudio = null; }
      if (prerecordedAudio) { prerecordedAudio.pause(); prerecordedAudio = null; }
      stopTalking();
      hideSubtitle();
    }

    // ===========================================
    // RIVE
    // ===========================================
    let riveInstance = null;
    let hasRive = false;
    let isTalkingInput = null;
    let visemeIDInput = null;
    let visemeTimer = null;
    let ttsLipSyncTimer = null;

    async function initRive() {
      log("Cargando Rive...");
      setStatus("Cargando avatar...", "loading");

      const Rive = RiveCanvas.Rive || RiveCanvas.default || RiveCanvas;

      if (typeof Rive !== "function") {
        fallbackToCSS("No Rive");
        return;
      }

      try {
        riveInstance = new Rive({
          src: CONFIG.RIVE_FILE,
          canvas: riveCanvas,
          stateMachines: CONFIG.STATE_MACHINE,
          autoplay: true,
          onLoad: onRiveLoad,
          onLoadError: onRiveError
        });
      } catch (e) {
        fallbackToCSS(e.message);
      }
    }

    function onRiveLoad() {
      setTimeout(() => {
        try {
          const inputs = riveInstance.stateMachineInputs(CONFIG.STATE_MACHINE);

          if (!inputs || inputs.length === 0) {
            fallbackToCSS("Sin inputs");
            return;
          }

          inputs.forEach(input => {
            if (input.name === "isTalking") isTalkingInput = input;
            else if (input.name === "VisemeID") visemeIDInput = input;
          });

          if (isTalkingInput && visemeIDInput) {
            hasRive = true;
            riveWrap.style.display = "grid";
            cssAvatar.style.display = "none";
            setStatus("Avatar listo", "ok");
            log("✓ Rive OK");
          } else {
            fallbackToCSS("Inputs incompletos");
          }
        } catch (e) {
          fallbackToCSS(e.message);
        }
      }, 100);
    }

    function onRiveError(err) {
      fallbackToCSS(String(err));
    }

    function fallbackToCSS(reason) {
      hasRive = false;
      riveWrap.style.display = "none";
      cssAvatar.style.display = "grid";
      setStatus("CSS fallback", "error");
      log("Fallback: " + reason);
    }

    // ===========================================
    // Lip Sync
    // ===========================================
    function stopTalking() {
      if (visemeTimer) { clearInterval(visemeTimer); visemeTimer = null; }
      if (ttsLipSyncTimer) { clearInterval(ttsLipSyncTimer); ttsLipSyncTimer = null; }

      if (hasRive) {
        if (isTalkingInput) isTalkingInput.value = false;
        if (visemeIDInput) visemeIDInput.value = 0;
      }

      if (presentationIsTalkingInput) presentationIsTalkingInput.value = false;
      if (presentationVisemeIDInput) presentationVisemeIDInput.value = 0;

      cssSetMouthOpen(0);
    }

    // Lip sync simple sin pausas
    function startTTSLipSync() {
      if (!hasRive && !isPresentationMode) {
        startCSSFakeTalking(99999);
        return;
      }

      if (isPresentationMode && presentationIsTalkingInput) {
        presentationIsTalkingInput.value = true;
      } else if (isTalkingInput) {
        isTalkingInput.value = true;
      }

      const targetVisemeInput = isPresentationMode ? presentationVisemeIDInput : visemeIDInput;

      if (targetVisemeInput) {
        if (ttsLipSyncTimer) clearInterval(ttsLipSyncTimer);

        const visemes = [0, 1, 2, 3, 4, 5, 6, 7, 8];
        let lastViseme = 0;

        ttsLipSyncTimer = setInterval(() => {
          let newViseme;
          do {
            newViseme = visemes[Math.floor(Math.random() * visemes.length)];
          } while (newViseme === lastViseme);
          lastViseme = newViseme;
          targetVisemeInput.value = newViseme;
        }, 90);
      }
    }

    // ===========================================
    // Lip Sync con Timestamps Manuales
    // ===========================================
    function startLipSyncWithTimestamps(pauseTimestamps = []) {
      if (!hasRive && !isPresentationMode) {
        startCSSFakeTalking(99999);
        return;
      }

      const targetIsTalkingInput = isPresentationMode ? presentationIsTalkingInput : isTalkingInput;
      const targetVisemeInput = isPresentationMode ? presentationVisemeIDInput : visemeIDInput;

      // Si no hay pausas definidas, usar lip-sync normal
      if (!pauseTimestamps || pauseTimestamps.length === 0) {
        log("Sin pausas definidas, lip-sync continuo");
        startTTSLipSync();
        return;
      }

      log("Lip-sync con " + pauseTimestamps.length + " pausas: " + pauseTimestamps.join(", ") + " ms");

      if (targetIsTalkingInput) targetIsTalkingInput.value = true;

      if (targetVisemeInput) {
        if (ttsLipSyncTimer) clearInterval(ttsLipSyncTimer);

        const visemes = [0, 1, 2, 3, 4, 5, 6, 7, 8];
        let lastViseme = 0;
        const startTime = performance.now();
        const pauseDuration = CONFIG.PAUSE_DURATION;

        // Crear rangos de pausa [inicio, fin]
        const pauseRanges = pauseTimestamps.map(t => ({
          start: t,
          end: t + pauseDuration
        }));

        ttsLipSyncTimer = setInterval(() => {
          const elapsed = performance.now() - startTime;

          // Verificar si estamos dentro de algún rango de pausa
          const inPause = pauseRanges.some(range =>
            elapsed >= range.start && elapsed < range.end
          );

          if (inPause) {
            // Estamos en pausa - cerrar boca
            targetVisemeInput.value = 0;
            if (targetIsTalkingInput) targetIsTalkingInput.value = false;
            return;
          }

          // No estamos en pausa - animar labios
          if (targetIsTalkingInput && !targetIsTalkingInput.value) {
            targetIsTalkingInput.value = true;
          }

          let newViseme;
          do {
            newViseme = visemes[Math.floor(Math.random() * visemes.length)];
          } while (newViseme === lastViseme);
          lastViseme = newViseme;
          targetVisemeInput.value = newViseme;
        }, 90);
      }
    }

    function startCSSFakeTalking(durationMs) {
      const start = performance.now();
      const tick = () => {
        const elapsed = performance.now() - start;
        if (elapsed >= durationMs) { cssSetMouthOpen(0); return; }
        const wave = Math.sin(elapsed / 85);
        cssSetMouthOpen(0.45 + 0.55 * wave);
        requestAnimationFrame(tick);
      };
      requestAnimationFrame(tick);
    }

    // ===========================================
    // Controls
    // ===========================================
    $("idleBtn").onclick = () => {
      log("Detenido");
      stopSpeaking();
      bubbleEl.textContent = "En espera…";
    };

    $("testTalkBtn").onclick = async () => {
      const testText = "Hola, soy tu asistente virtual. ¿En qué puedo ayudarte?";
      bubbleEl.textContent = testText;
      if (isPresentationMode) showSubtitle(testText);
      log("Test TTS");
      await speak(testText);
    };

    // ===========================================
    // WebSocket
    // ===========================================
    const qp = new URLSearchParams(location.search);
    const BACKEND_HOST = qp.get("backend") || CONFIG.BACKEND_HOST;
    const wsProto = location.protocol === "https:" ? "wss://" : "ws://";
    let ws = null;
    let wsReconnectTimer = null;
    let currentAudioId = null;

    function connectWebSocket() {
      if (wsReconnectTimer) clearTimeout(wsReconnectTimer);

      try {
        log("WS: " + BACKEND_HOST);
        ws = new WebSocket(wsProto + BACKEND_HOST);

        ws.onopen = () => log("WS conectado ✓");
        ws.onclose = () => {
          log("WS cerrado");
          wsReconnectTimer = setTimeout(connectWebSocket, 5000);
        };
        ws.onerror = () => log("WS error");

        ws.onmessage = async (ev) => {
          let msg;
          try { msg = JSON.parse(ev.data); } catch { return; }

          log("WS: " + msg.type);

          if (msg.type === "bot_speaking_start") {
            const audioId = msg.audioId || msg.lineId || null;

            // ⚡ FILTRO: Solo procesar si el audioId está en AUDIO_BANK
            if (!audioId || !AUDIO_BANK[audioId]) {
              log("⏭️ Ignorando mensaje (no es audio pregenerado): " + audioId);
              return;
            }

            currentAudioId = audioId;

            // Si es intro_1 y estamos en presentación, mostrar avatar
            if (audioId === CONFIG.PRESENTATION_START_ID && isPresentationMode) {
              showPresentationAvatar();
              await new Promise(r => setTimeout(r, 1000));
            }

            const entry = AUDIO_BANK[audioId];

            bubbleEl.textContent = entry.text;
            if (isPresentationMode) showSubtitle(entry.text);

            // Reproducir audio pregenerado con timestamps
            if (msg.audioUrl) {
              try {
                await playPrerecordedAudio(msg.audioUrl, entry.pauses || []);
              } catch (e) {
                await speak(entry.text, audioId);
              }
            } else {
              await speak(entry.text, audioId);
            }

            // Si es despedida_1 y estamos en presentación, ocultar avatar
            if (audioId === CONFIG.PRESENTATION_END_ID && isPresentationMode) {
              hidePresentationAvatar();
            }
          }

          if (msg.type === "bot_speaking_end") {
            if (currentAudioId === CONFIG.PRESENTATION_END_ID && isPresentationMode) {
              hidePresentationAvatar();
            }
            stopSpeaking();
            currentAudioId = null;
          }
        };
      } catch (e) {
        log("WS error: " + e.message);
        wsReconnectTimer = setTimeout(connectWebSocket, 5000);
      }
    }

    // ===========================================
    // Fullscreen normal
    // ===========================================
    const fullscreenBtn = $("fullscreenBtn");
    let isFullscreen = false;

    fullscreenBtn.onclick = () => {
      isFullscreen = !isFullscreen;

      if (isFullscreen) {
        riveWrap.classList.add("fullscreen");
        fullscreenBtn.innerHTML = '<i data-lucide="minimize-2"></i>';
        lucide.createIcons();
        if (riveWrap.requestFullscreen) riveWrap.requestFullscreen().catch(() => { });
      } else {
        riveWrap.classList.remove("fullscreen");
        fullscreenBtn.innerHTML = '<i data-lucide="maximize-2"></i>';
        lucide.createIcons();
        if (document.exitFullscreen && document.fullscreenElement) document.exitFullscreen().catch(() => { });
      }
    };

    document.addEventListener("fullscreenchange", () => {
      if (!document.fullscreenElement && isFullscreen) {
        isFullscreen = false;
        riveWrap.classList.remove("fullscreen");
        fullscreenBtn.innerHTML = '<i data-lucide="maximize-2"></i>';
        lucide.createIcons();
      }
    });

    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        if (isPresentationMode) exitPresentationMode();
        else if (isFullscreen) {
          isFullscreen = false;
          riveWrap.classList.remove("fullscreen");
          fullscreenBtn.innerHTML = '<i data-lucide="maximize-2"></i>';
          lucide.createIcons();
        }
      }
    });

    // ===========================================
    // Init
    // ===========================================
    log("Iniciando...");
    await initRive();
    connectWebSocket();
    bubbleEl.textContent = "En espera…";
    lucide.createIcons();
  </script>
</body>

</html>