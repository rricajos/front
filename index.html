<!doctype html>
<html lang="es">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gespropiedad Avatar</title>
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
  <style>
    :root {
      --brand-primary: #1ca4af;
      --brand-secondary: #1c3768;
      --bg-dark: #0b0f14;
      --bg-card: #0f1621;
      --bg-input: #0a0e14;
      --border-color: #1f2a3a;
      --border-light: #2a3c54;
      --text-primary: #e6edf3;
      --text-muted: rgba(230, 237, 243, 0.6);
      --success: #22c55e;
      --error: #ef4444;
      --warning: #eab308;
    }

    * { box-sizing: border-box; }
    
    body {
      margin: 0;
      font-family: system-ui, -apple-system, sans-serif;
      background: linear-gradient(135deg, var(--bg-dark) 0%, #1a1f2e 100%);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }

    /* ============================
       OVERLAY DE INICIO
       ============================ */
    .start-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, #0b0f14 0%, #131a24 50%, #0d1117 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      gap: 20px;
      padding: 24px;
    }

    .start-overlay.hidden {
      display: none;
    }

    .start-logo {
      width: 100px;
      height: auto;
      opacity: 0.9;
    }

    .start-overlay h1 {
      font-size: 1.6rem;
      margin: 0;
      color: #fff;
      font-weight: 600;
      letter-spacing: -0.02em;
      text-align: center;
    }

    .start-overlay p {
      font-size: 0.95rem;
      color: var(--text-muted);
      margin: 0;
      text-align: center;
      max-width: 320px;
      line-height: 1.5;
    }

    .start-buttons {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 12px;
      width: 100%;
      max-width: 300px;
    }

    .start-btn {
      background: linear-gradient(135deg, var(--brand-primary) 0%, var(--brand-secondary) 100%);
      color: white;
      border: none;
      padding: 14px 28px;
      font-size: 0.95rem;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.25s ease;
      box-shadow: 0 4px 20px rgba(28, 164, 175, 0.25);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      width: 100%;
    }

    .start-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 28px rgba(28, 164, 175, 0.35);
    }

    .start-btn:active {
      transform: translateY(0);
    }

    .start-btn.secondary {
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      box-shadow: none;
    }

    .start-btn.secondary:hover {
      background: rgba(255, 255, 255, 0.12);
      box-shadow: none;
    }

    .start-btn i {
      width: 18px;
      height: 18px;
      flex-shrink: 0;
    }

    /* ============================
       MODO PRESENTACIÓN
       ============================ */
    body.presentation-mode {
      background: #000;
      padding: 0;
    }

    body.presentation-mode .stage {
      display: none;
    }

    .presentation-container {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #000;
      z-index: 9999;
      align-items: center;
      justify-content: center;
    }

    body.presentation-mode .presentation-container {
      display: flex;
    }

    .presentation-avatar {
      opacity: 0;
      transform: scale(0.92);
      transition: opacity 1.8s ease-out, transform 1.8s ease-out;
      position: relative;
    }

    .presentation-avatar.visible {
      opacity: 1;
      transform: scale(1);
    }

    .presentation-avatar.fading-out {
      opacity: 0;
      transform: scale(0.92);
      transition: opacity 2.5s ease-in, transform 2.5s ease-in;
    }

    .presentation-avatar .pres-rive-wrap {
      width: 100vmin;
      height: 100vmin;
      max-width: 700px;
      max-height: 700px;
      display: grid;
      place-items: center;
    }

    .presentation-avatar #presentationCanvas {
      width: 100%;
      height: 100%;
    }

    /* Logo de fondo grande y visible */
    .presentation-container::before {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 105vh;
      height: 105vh;
      opacity: 0;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 226.1 219.1'%3E%3Cdefs%3E%3ClinearGradient id='a' x1='56' y1='178.7' x2='56' y2='0' gradientUnits='userSpaceOnUse'%3E%3Cstop offset='0' stop-color='%231ca4af'/%3E%3Cstop offset='1' stop-color='%231c3768'/%3E%3C/linearGradient%3E%3ClinearGradient id='b' x1='139.2' y1='53.5' x2='232.6' y2='215.2' href='%23a'/%3E%3C/defs%3E%3Cpolygon fill='url(%23a)' points='0 0 73.6 111 26.2 178.7 65.6 178.7 111.9 109.9 41.8 0 0 0'/%3E%3Cpolygon fill='url(%23b)' points='194.6 45.6 150.2 111 226 219 186.7 219 111.9 109.9 152.9 45.6 194.6 45.6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: center;
      background-size: contain;
      pointer-events: none;
      z-index: 0;
      transition: opacity 1.8s ease-out;
    }

    .presentation-container.show-logo::before {
      opacity: 0.33;
    }

    .presentation-subtitle {
      position: fixed;
      bottom: 4%;
      left: 50%;
      transform: translateX(-50%);
      width: auto;
      max-width: 85%;
      text-align: center;
      font-size: clamp(1rem, 1.8vw, 1.25rem);
      line-height: 1.5;
      color: #fff;
      text-shadow: 0 2px 12px rgba(0, 0, 0, 0.8);
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 10001;
      padding: 14px 28px;
      background: rgba(0, 0, 0, 0.75);
      border-radius: 12px;
      backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .presentation-subtitle.visible {
      opacity: 1;
    }

    .presentation-subtitle .segment {
      color: #fff;
      text-shadow: 0 0 20px rgba(28, 164, 175, 0.6), 0 2px 12px rgba(0, 0, 0, 0.8);
    }

    .exit-presentation-btn {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.12);
      color: white;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      cursor: pointer;
      z-index: 10002;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.3s, background 0.2s;
    }

    .exit-presentation-btn:hover {
      background: rgba(255, 255, 255, 0.15);
      opacity: 1 !important;
    }

    .exit-presentation-btn i {
      width: 20px;
      height: 20px;
    }

    .presentation-container:hover .exit-presentation-btn {
      opacity: 0.4;
    }

    /* ============================
       PANEL PRINCIPAL
       ============================ */
    .stage {
      width: 100%;
      max-width: 900px;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, .35);
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
      padding: 28px;
      align-items: center;
    }

    @media (max-width: 800px) {
      .stage {
        grid-template-columns: 1fr;
        gap: 20px;
        padding: 20px;
      }
      .avatar { order: 1; }
      .panel { order: 2; }
    }

    @media (max-width: 480px) {
      body { padding: 8px; }
      .stage {
        border-radius: 16px;
        padding: 16px;
        gap: 16px;
      }
      .rive-wrap {
        width: 220px !important;
        height: 220px !important;
      }
      #riveCanvas {
        width: 200px !important;
        height: 200px !important;
      }
      .bubble {
        min-height: 70px !important;
        font-size: 15px !important;
      }
      .btn-row { flex-direction: column; }
      .btn { width: 100%; }
    }

    /* Avatar */
    .avatar {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 260px;
      position: relative;
    }

    .rive-wrap {
      width: 280px;
      height: 280px;
      display: grid;
      place-items: center;
      border-radius: 20px;
      background: radial-gradient(circle at 30% 30%, #1a2535, #0d121b 70%);
      border: 1px solid #223146;
      box-shadow: 
        inset 0 0 0 1px rgba(255, 255, 255, 0.03),
        0 8px 32px rgba(0, 0, 0, 0.3);
      overflow: hidden;
      position: relative;
    }

    #riveCanvas {
      width: 260px;
      height: 260px;
    }

    /* CSS Fallback */
    .css-avatar {
      display: none;
      place-items: center;
    }

    .head {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #2b3b52, #111823 70%);
      position: relative;
      border: 1px solid #243247;
      animation: breathe 5.5s ease-in-out infinite;
    }

    @keyframes breathe {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-2px); }
    }

    .eye {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--text-primary);
      position: absolute;
      top: 65px;
      overflow: hidden;
    }

    .eye.left { left: 55px; }
    .eye.right { right: 55px; }

    .eye::after {
      content: "";
      position: absolute;
      inset: 0;
      background: var(--bg-card);
      transform: translateY(-120%);
      animation: blink 6s infinite;
    }

    @keyframes blink {
      0%, 92%, 100% { transform: translateY(-120%); }
      94%, 96% { transform: translateY(0%); }
    }

    .pupil {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background: var(--bg-dark);
      position: absolute;
      top: 6px;
      left: 6px;
    }

    .mouth {
      width: 60px;
      height: 12px;
      background: var(--text-primary);
      border-radius: 0 0 12px 12px;
      position: absolute;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%) scaleY(0.2);
      transform-origin: center top;
      transition: transform 40ms linear;
    }

    /* Panel */
    .panel {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .status-bar {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      background: var(--bg-input);
      border-radius: 10px;
      border: 1px solid var(--border-color);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #666;
      flex-shrink: 0;
    }

    .status-dot.ok { background: var(--success); }
    .status-dot.error { background: var(--error); }
    .status-dot.loading { background: var(--warning); animation: pulse 1s infinite; }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    .status-text {
      font-size: 13px;
      color: var(--text-muted);
      flex: 1;
    }

    .debug {
      font-size: 10px;
      color: var(--text-muted);
      font-family: 'SF Mono', Monaco, Consolas, monospace;
      max-height: 60px;
      overflow-y: auto;
      background: var(--bg-input);
      padding: 10px 12px;
      border-radius: 8px;
      white-space: pre-wrap;
      word-break: break-all;
      line-height: 1.4;
      border: 1px solid var(--border-color);
    }

    .bubble {
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 14px 16px;
      min-height: 90px;
      max-height: 130px;
      overflow-y: auto;
      font-size: 15px;
      line-height: 1.5;
      color: var(--text-primary);
    }

    /* Buttons */
    .btn-row {
      display: flex;
      gap: 10px;
    }

    .btn {
      background: rgba(255, 255, 255, 0.06);
      color: var(--text-primary);
      border: 1px solid var(--border-light);
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 500;
      font-size: 13px;
      transition: all 0.15s;
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .btn:active {
      transform: scale(0.97);
    }

    .btn i {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
    }

    .btn.primary {
      background: linear-gradient(135deg, var(--brand-primary) 0%, var(--brand-secondary) 100%);
      border: none;
      box-shadow: 0 2px 12px rgba(28, 164, 175, 0.2);
    }

    .btn.primary:hover {
      box-shadow: 0 4px 16px rgba(28, 164, 175, 0.3);
    }

    .btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* Settings */
    .settings-section {
      background: var(--bg-input);
      border-radius: 10px;
      padding: 12px 14px;
      border: 1px solid var(--border-color);
    }

    .settings-section label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 8px;
    }

    .settings-section label i {
      width: 14px;
      height: 14px;
    }

    .voice-select {
      background: var(--bg-dark);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 13px;
      width: 100%;
    }

    .voice-select:focus {
      outline: none;
      border-color: var(--brand-primary);
    }

    /* Fullscreen button */
    .fullscreen-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.1);
      width: 32px;
      height: 32px;
      padding: 0;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.2s, background 0.2s;
      color: white;
    }

    .fullscreen-btn i {
      width: 16px;
      height: 16px;
    }

    .rive-wrap:hover .fullscreen-btn {
      opacity: 0.7;
    }

    .fullscreen-btn:hover {
      opacity: 1 !important;
      background: rgba(0, 0, 0, 0.6);
    }

    /* Rive fullscreen mode */
    .rive-wrap.fullscreen {
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      width: 100vw !important;
      height: 100vh !important;
      max-width: none !important;
      border-radius: 0 !important;
      z-index: 9999;
      background: #000;
    }

    .rive-wrap.fullscreen #riveCanvas {
      width: 100vmin !important;
      height: 100vmin !important;
    }

    .rive-wrap.fullscreen .fullscreen-btn {
      top: 16px;
      right: 16px;
      width: 40px;
      height: 40px;
      opacity: 0.5;
    }
  </style>
</head>

<body>
  <!-- Overlay de inicio -->
  <div class="start-overlay" id="startOverlay">
    <svg class="start-logo" viewBox="0 0 226.1 219.1" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <linearGradient id="grad1" x1="56" y1="178.7" x2="56" y2="0" gradientUnits="userSpaceOnUse">
          <stop offset="0" stop-color="#1ca4af"/>
          <stop offset="1" stop-color="#1c3768"/>
        </linearGradient>
        <linearGradient id="grad2" x1="139.2" y1="53.5" x2="232.6" y2="215.2" gradientUnits="userSpaceOnUse">
          <stop offset="0" stop-color="#1ca4af"/>
          <stop offset="1" stop-color="#1c3768"/>
        </linearGradient>
      </defs>
      <polygon fill="url(#grad1)" points="0 0 73.6 111 26.2 178.7 65.6 178.7 111.9 109.9 41.8 0 0 0"/>
      <polygon fill="url(#grad2)" points="194.6 45.6 150.2 111 226 219 186.7 219 111.9 109.9 152.9 45.6 194.6 45.6"/>
    </svg>
    <h1>Asistente Virtual</h1>
    <p>Selecciona cómo quieres interactuar con el avatar</p>
    <div class="start-buttons">
      <button class="start-btn" id="startPresentationBtn">
        <i data-lucide="tv"></i>
        Modo Presentación
      </button>
      <button class="start-btn secondary" id="startNormalBtn" disabled>
        <i data-lucide="settings-2"></i>
        Panel de Control
      </button>
    </div>
  </div>

  <!-- Contenedor presentación fullscreen -->
  <div class="presentation-container" id="presentationContainer">
    <button class="exit-presentation-btn" id="exitPresentationBtn" title="Salir (ESC)" disabled>
      <i data-lucide="x"></i>
    </button>
    <div class="presentation-avatar" id="presentationAvatar">
      <div class="pres-rive-wrap">
        <canvas id="presentationCanvas" width="800" height="800"></canvas>
      </div>
    </div>
    <div class="presentation-subtitle" id="presentationSubtitle"></div>
  </div>

  <!-- Panel principal -->
  <div class="stage">
    <div class="avatar">
      <div class="rive-wrap" id="riveWrap">
        <button class="fullscreen-btn" id="fullscreenBtn" title="Pantalla completa">
          <i data-lucide="maximize-2"></i>
        </button>
        <canvas id="riveCanvas" width="600" height="600"></canvas>
      </div>
      <div class="css-avatar" id="cssAvatar">
        <div class="head">
          <div class="eye left"><div class="pupil"></div></div>
          <div class="eye right"><div class="pupil"></div></div>
          <div class="mouth" id="cssMouth"></div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="status-bar">
        <span class="status-dot loading" id="statusDot"></span>
        <span class="status-text" id="statusText">Inicializando...</span>
      </div>

      <div class="debug" id="debug"></div>

      <div class="bubble" id="bubble">Listo para recibir eventos.</div>
      
      <div class="btn-row">
        <button class="btn primary" id="testTalkBtn">
          <i data-lucide="play"></i>
          Test
        </button>
        <button class="btn" id="idleBtn">
          <i data-lucide="pause"></i>
          Detener
        </button>
      </div>
      
      <div class="btn-row">
        <button class="btn primary" id="enterPresentationBtn">
          <i data-lucide="tv"></i>
          Modo Presentación
        </button>
      </div>
      
      <div class="settings-section">
        <label>
          <i data-lucide="volume-2"></i>
          Voz TTS
        </label>
        <select id="voiceSelect" class="voice-select">
          <option value="">Cargando voces...</option>
        </select>
      </div>
    </div>
  </div>

  <script type="module">
    // ===========================================
    // CONFIGURACIÓN
    // ===========================================
    const CONFIG = {
      ELEVENLABS_API_KEY: "sk_ed00c8630aeb0240abba435c3f0a4afcd6794a79c0d1aba6",
      ELEVENLABS_VOICE_ID: "uU1QvfOppdkePeLtG9pI",
      ELEVENLABS_MODEL: "eleven_multilingual_v2",
      BACKEND_HOST: "hogar-avatar-api.conexiatec.com",
      RIVE_FILE: "./avatar.riv",
      STATE_MACHINE: "State Machine",
      USE_BROWSER_TTS_FALLBACK: true,
      PRESENTATION_START_ID: "intro_1",
      PRESENTATION_END_ID: "despedida_1",
      
      // Duración de cada pausa de labios (ms)
      PAUSE_DURATION: 500,
    };

    // ===========================================
    // BANCO DE AUDIOS CON TIMESTAMPS MANUALES
    // 
    // pauses: Array de timestamps (en milisegundos) donde 
    //         los labios deben cerrarse durante PAUSE_DURATION ms
    // 
    // Ejemplo: pauses: [1500, 3200, 5800]
    //          - En el ms 1500, cierra labios 500ms
    //          - En el ms 3200, cierra labios 500ms
    //          - En el ms 5800, cierra labios 500ms
    //
    // TIP: Reproduce el audio y anota los segundos donde hay pausas,
    //      luego multiplica por 1000 para obtener milisegundos.
    //      Ejemplo: pausa en 2.3 segundos → 2300
    // ===========================================
    const AUDIO_BANK = {
      "intro_1": {
        text: "Hola a todos. Perdonad mi entrada… estaba esperando. Y he pensado: 'igual os habíais olvidado de mí'.",
        audio: "./audio/intro_1.mp3",
        // Duración: 6.58s - Timestamps = cuando empieza cada nuevo segmento
        pauses: [
          1331,  // empieza "Perdonad mi entrada…"
          3074,  // empieza "Y he pensado:..."
        ]
      },
      "que_es_1": {
        text: "Buenas noches a todos. Y sí, es cierto: no duermo… no pido vacaciones… y los lunes no me afectan. Pero prometo ser simpática igualmente. Me presento: soy la nueva IA de Gestpropiedad. Vengo a echar una mano en tres frentes. Primero, con los clientes. Cuando la oficina cierre, me quedo de guardia para que ningún cliente se quede sin respuesta. Segundo, en la web. Ayudaré a entender mejor cada vivienda y a guiar a cada cliente hasta el asesor correcto. Y tercero, el más importante: vosotros. Os ayudaré a encontrar la información que necesitéis en segundos, y a responder con más claridad… sin quitaros vuestro estilo.",
        audio: "./audio/que_es_1.mp3",
        // Duración: 40.80s - Timestamps = cuando empieza cada nuevo segmento
        pauses: [
          1802,  // "Y sí, es cierto:..."
          5573,  // "y los lunes no me afectan..."
          7806,  // "Pero prometo ser simpática..."
          11148, // "Me presento:..."
          12593, // "Vengo a echar una mano..."
          15476, // "Primero, con los clientes..."
          18818, // "Cuando la oficina cierre..."
          24400, // "Segundo, en la web..."
          29701, // "Y tercero, el más importante:..."
          30760, // "vosotros..."
          32274, // "Os ayudaré a encontrar..."
          33460, // "la información..."
          36753, // "y a responder con más claridad..."
          38701, // "sin quitaros vuestro estilo."
        ]
      },
      "aprendizaje_1": {
        text: "No es todo, esto es solo el principio. Hoy es, literalmente, mi nacimiento. A partir de ahora iré aprendiendo cada día: de las consultas… de cómo trabajáis… de lo que necesitan los clientes… y de los datos que me ha proporcionado el equipo. Cuanto más se me use, mejor podré ayudar… y en más ámbitos. Prometo crecer rápido… y sin adolescencia rebelde.",
        audio: "./audio/aprendizaje_1.mp3",
        // Duración: 24.69s - Timestamps = cuando empieza cada nuevo segmento
        pauses: [
          2490,  // "Hoy es, literalmente..."
          6319,  // "A partir de ahora..."
          9503,  // "de las consultas…"
          12309, // "de lo que necesitan..."
          14803, // "y de los datos..."
          17495, // "Cuanto más se me use..."
          19382, // "y en más ámbitos..."
          23070, // "y sin adolescencia rebelde."
        ]
      },
      "despedida_1": {
        text: "Exacto. No tengo nombre. De momento soy 'la IA de Gestpropiedad'… y suena frío, poco personal... Como vamos a trabajar juntos, me gustaría que fuerais vosotros, mi equipo, quienes elijáis mi nombre esta noche. Yo me despido aquí y os dejo con Alejandro para que os explique las opciones. Para cuando vuelva… ya será con mi nombre oficial. Y tranquilos: ninguna opción es 'ChatPaco' ni 'BotManolo'... …de eso podéis estar seguros... Ha sido un placer saludaros por primera vez. Gracias, y nos vemos muy pronto.",
        audio: "./audio/despedida_1.mp3",
        // Duración: 35.60s - Timestamps = cuando empieza cada nuevo segmento
        pauses: [
          1258,  // "No tengo nombre..."
          5190,  // "De momento soy..."
          8186,  // "Como vamos a trabajar juntos..."
          13324, // "Yo me despido aquí..."
          20232, // "Para cuando vuelva…"
          21817, // "ya será con mi nombre oficial..."
          23913, // "Y tranquilos:..."
          30828, // "Ha sido un placer..."
          33692, // "Gracias, y nos vemos..."
        ]
      },
    };

    const AUDIO_BY_TEXT = {};

    // ===========================================
    // Importar Rive
    // ===========================================
    import RiveCanvas from "https://cdn.jsdelivr.net/npm/@rive-app/canvas@2.21.6/+esm";

    // ===========================================
    // DOM
    // ===========================================
    const $ = id => document.getElementById(id);
    const statusDot = $("statusDot");
    const statusText = $("statusText");
    const debugEl = $("debug");
    const bubbleEl = $("bubble");
    const riveWrap = $("riveWrap");
    const riveCanvas = $("riveCanvas");
    const cssAvatar = $("cssAvatar");
    const cssMouth = $("cssMouth");
    const voiceSelect = $("voiceSelect");
    const startOverlay = $("startOverlay");
    const startNormalBtn = $("startNormalBtn");
    const startPresentationBtn = $("startPresentationBtn");

    const presentationContainer = $("presentationContainer");
    const presentationAvatar = $("presentationAvatar");
    const presentationCanvas = $("presentationCanvas");
    const presentationSubtitle = $("presentationSubtitle");
    const exitPresentationBtn = $("exitPresentationBtn");
    const enterPresentationBtn = $("enterPresentationBtn");

    let isPresentationMode = false;
    let presentationRiveInstance = null;
    let presentationIsTalkingInput = null;
    let presentationVisemeIDInput = null;

    function setStatus(text, state = "loading") {
      statusText.textContent = text;
      statusDot.className = "status-dot " + state;
    }

    function log(msg) {
      console.log("[Avatar]", msg);
      const time = new Date().toLocaleTimeString("es", { hour12: false });
      debugEl.textContent = `[${time}] ${msg}\n` + debugEl.textContent.slice(0, 400);
    }

    // ===========================================
    // AUDIO UNLOCK
    // ===========================================
    async function unlockAudio() {
      try {
        const silentAudio = new Audio("data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2teleCAHQJnx+aCFNgRDmvz/mXoxBEaZ/P+YdywFR5r8/5d3KgZIm/z/lnkpB0mc/P+VeigISp38/5R7JwlLnfz/k3wmCkye/P+SfSULTZ/8/5F+JAxOoPz/kH8jDU+h/P+PgCIOUKL8/46BIQ9Ro/z/jYIfEFKk/P+MgyAQU6X8/4uEHxFUpvz/ioUeElWn/P+Jhh0TV6j8/4iHHBRYqfz/h4gcFVqq/P+GiRsWW6v8/4WKGhdcrPz/hIoZGF2t/P+DixgZXq78/4KMGB5fr/z/gY0XH2Cw/P+AjhYgYbH8/3+PFSFisfz/fpAUI2Oz/P99kRMkZLT8/3ySEiVltfz/e5MSJGW1");
        silentAudio.volume = 0.01;
        await silentAudio.play();
        silentAudio.pause();
        
        if (synth) {
          const u = new SpeechSynthesisUtterance("");
          u.volume = 0;
          synth.speak(u);
          synth.cancel();
        }
        
        log("Audio OK ✓");
        return true;
      } catch (e) {
        log("Audio error: " + e.message);
        return false;
      }
    }

    // Modo normal
    startNormalBtn.onclick = async () => {
      await unlockAudio();
      startOverlay.classList.add("hidden");
    };

    // Modo presentación desde overlay
    startPresentationBtn.onclick = async () => {
      await unlockAudio();
      startOverlay.classList.add("hidden");
      await enterPresentationMode();
    };

    // ===========================================
    // MODO PRESENTACIÓN
    // ===========================================
    async function enterPresentationMode() {
      log("→ Modo presentación");
      isPresentationMode = true;
      document.body.classList.add("presentation-mode");
      
      if (!presentationRiveInstance) {
        await initPresentationRive();
      }
      
      presentationAvatar.classList.remove("visible", "fading-out");
      presentationSubtitle.classList.remove("visible");
      presentationSubtitle.textContent = "";
    }

    function exitPresentationMode() {
      log("← Saliendo de presentación");
      isPresentationMode = false;
      document.body.classList.remove("presentation-mode");
      presentationAvatar.classList.remove("visible", "fading-out");
      presentationContainer.classList.remove("show-logo");
      presentationSubtitle.classList.remove("visible");
    }

    function showPresentationAvatar() {
      log("✨ Avatar apareciendo");
      presentationContainer.classList.add("show-logo");
      presentationAvatar.classList.remove("fading-out");
      presentationAvatar.classList.add("visible");
    }

    function hidePresentationAvatar() {
      log("✨ Avatar desapareciendo");
      presentationAvatar.classList.add("fading-out");
      presentationSubtitle.classList.remove("visible");
      
      setTimeout(() => {
        presentationContainer.classList.remove("show-logo");
        presentationAvatar.classList.remove("visible", "fading-out");
      }, 3000);
    }

    function showSubtitle(text) {
      if (!isPresentationMode) return;
      presentationSubtitle.textContent = text;
      presentationSubtitle.classList.add("visible");
    }

    function hideSubtitle() {
      stopKaraokeSync();
      presentationSubtitle.classList.remove("visible");
    }

    // ===========================================
    // KARAOKE SYNC - Solo muestra segmento activo
    // ===========================================
    let karaokeTimer = null;
    let karaokeSegments = [];
    let karaokeTimestamps = [];
    let karaokeStartTime = 0;

    function showSubtitleKaraoke(text, pauseTimestamps = []) {
      if (!isPresentationMode) return;
      
      stopKaraokeSync();
      
      // Si no hay pausas, guardar texto completo
      if (!pauseTimestamps || pauseTimestamps.length === 0) {
        karaokeSegments = [text];
        karaokeTimestamps = [0];
        return;
      }

      // Dividir texto en segmentos por puntuación natural
      const segments = splitTextIntoSegments(text, pauseTimestamps.length + 1);
      karaokeSegments = segments;
      
      // Timestamps: segmento 0 empieza en 0, luego cada pausa marca el inicio del siguiente
      karaokeTimestamps = [0, ...pauseTimestamps];
      
      // NO mostrar nada aún - se mostrará cuando el audio empiece
    }

    function startKaraokeSync() {
      if (karaokeSegments.length === 0) return;
      
      karaokeStartTime = performance.now();
      let currentIndex = 0;
      
      // Mostrar primer segmento ahora que el audio está sonando
      presentationSubtitle.innerHTML = `<span class="segment active">${karaokeSegments[0]}</span>`;
      presentationSubtitle.classList.add("visible");
      
      log("▶ Karaoke iniciado con " + karaokeSegments.length + " segmentos");
      
      karaokeTimer = setInterval(() => {
        const elapsed = performance.now() - karaokeStartTime;
        
        // Encontrar qué segmento debería estar activo
        let newIndex = 0;
        for (let i = 0; i < karaokeTimestamps.length; i++) {
          if (elapsed >= karaokeTimestamps[i]) {
            newIndex = i;
          }
        }
        
        // Solo actualizar si cambió y es válido
        if (newIndex !== currentIndex && newIndex < karaokeSegments.length) {
          currentIndex = newIndex;
          presentationSubtitle.innerHTML = `<span class="segment active">${karaokeSegments[currentIndex]}</span>`;
        }
      }, 50);
    }

    function splitTextIntoSegments(text, numSegments) {
      if (numSegments <= 1) return [text];
      
      // Dividir por puntuación natural: . ; … y después de :
      const parts = [];
      let current = '';
      
      for (let i = 0; i < text.length; i++) {
        current += text[i];
        if ((text[i] === '.' || text[i] === ';' || text[i] === '…') ||
            (text[i] === ':' && text[i+1] === ' ')) {
          if (current.trim()) {
            parts.push(current.trim());
            current = '';
          }
        }
      }
      if (current.trim()) parts.push(current.trim());
      
      // Si tenemos el número correcto de partes, usarlas
      if (parts.length === numSegments) return parts;
      
      // Si tenemos más partes, agrupar
      if (parts.length > numSegments) {
        const result = [];
        const partsPerSeg = Math.ceil(parts.length / numSegments);
        for (let i = 0; i < numSegments; i++) {
          const start = i * partsPerSeg;
          const end = Math.min(start + partsPerSeg, parts.length);
          result.push(parts.slice(start, end).join(' '));
        }
        return result;
      }
      
      // Si tenemos menos partes, devolver lo que hay
      return parts.length > 0 ? parts : [text];
    }

    function stopKaraokeSync() {
      if (karaokeTimer) {
        clearInterval(karaokeTimer);
        karaokeTimer = null;
      }
      karaokeSegments = [];
      karaokeTimestamps = [];
    }

    async function initPresentationRive() {
      log("Cargando Rive (presentación)...");
      
      const Rive = RiveCanvas.Rive || RiveCanvas.default || RiveCanvas;

      return new Promise((resolve) => {
        try {
          presentationRiveInstance = new Rive({
            src: CONFIG.RIVE_FILE,
            canvas: presentationCanvas,
            stateMachines: CONFIG.STATE_MACHINE,
            autoplay: true,
            onLoad: () => {
              setTimeout(() => {
                try {
                  const inputs = presentationRiveInstance.stateMachineInputs(CONFIG.STATE_MACHINE);
                  if (inputs && inputs.length > 0) {
                    inputs.forEach(input => {
                      if (input.name === "isTalking") presentationIsTalkingInput = input;
                      else if (input.name === "VisemeID") presentationVisemeIDInput = input;
                    });
                    log("✓ Rive presentación OK");
                  }
                  resolve();
                } catch (e) {
                  log("Error inputs: " + e.message);
                  resolve();
                }
              }, 100);
            },
            onLoadError: (err) => {
              log("Error Rive: " + err);
              resolve();
            }
          });
        } catch (e) {
          log("Error Rive: " + e.message);
          resolve();
        }
      });
    }

    exitPresentationBtn.onclick = exitPresentationMode;
    enterPresentationBtn.onclick = enterPresentationMode;

    // ===========================================
    // CSS Fallback
    // ===========================================
    function cssSetMouthOpen(value) {
      const scale = 0.2 + (value * 0.8);
      cssMouth.style.transform = `translateX(-50%) scaleY(${scale})`;
    }

    // ===========================================
    // TTS
    // ===========================================
    let synth = window.speechSynthesis;
    let voices = [];
    let selectedVoice = null;
    let currentUtterance = null;

    let voicesLoaded = false;
    
    function loadVoices() {
      voices = synth.getVoices();
      if (voices.length === 0) return; // Esperar a que haya voces
      
      // Filtrar voces de Microsoft (causan eco)
      const filteredVoices = voices.filter(v => !v.name.toLowerCase().includes('microsoft'));
      const spanishVoices = filteredVoices.filter(v => v.lang.startsWith('es'));
      const otherVoices = filteredVoices.filter(v => !v.lang.startsWith('es'));
      const sortedVoices = [...spanishVoices, ...otherVoices];
      
      // Evitar recargar si ya estaban cargadas
      if (voicesLoaded && voiceSelect.options.length === sortedVoices.length) return;
      voicesLoaded = true;
      
      voiceSelect.innerHTML = '';
      
      if (sortedVoices.length === 0) {
        voiceSelect.innerHTML = '<option value="">Sin voces</option>';
        return;
      }
      
      sortedVoices.forEach((voice, i) => {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `${voice.name} (${voice.lang})`;
        if (voice.lang.startsWith('es') && !selectedVoice) {
          option.selected = true;
          selectedVoice = voice;
        }
        voiceSelect.appendChild(option);
      });
      
      if (!selectedVoice && sortedVoices.length > 0) {
        selectedVoice = sortedVoices[0];
        voiceSelect.selectedIndex = 0;
      }
      
      log("Voces: " + sortedVoices.length);
    }

    if (synth.onvoiceschanged !== undefined) {
      synth.onvoiceschanged = loadVoices;
    }
    loadVoices();

    voiceSelect.addEventListener('change', () => {
      const allVoices = synth.getVoices();
      // Filtrar voces de Microsoft (causan eco)
      const filteredVoices = allVoices.filter(v => !v.name.toLowerCase().includes('microsoft'));
      const spanishVoices = filteredVoices.filter(v => v.lang.startsWith('es'));
      const otherVoices = filteredVoices.filter(v => !v.lang.startsWith('es'));
      const sortedVoices = [...spanishVoices, ...otherVoices];
      selectedVoice = sortedVoices[voiceSelect.value] || null;
    });

    function speak(text, audioId = null) {
      return new Promise(async (resolve) => {
        if (!text && !audioId) { resolve(); return; }

        // ⚡ Detener cualquier audio anterior para evitar eco/superposición
        stopSpeaking();

        if (audioId && AUDIO_BANK[audioId]) {
          const entry = AUDIO_BANK[audioId];
          log("Audio: " + audioId);
          bubbleEl.textContent = entry.text;
          if (isPresentationMode) showSubtitleKaraoke(entry.text, entry.pauses || []);
          try {
            // Pasar los timestamps de pausa al reproductor
            await playPrerecordedAudio(entry.audio, entry.pauses || []);
            resolve();
            return;
          } catch (e) {
            log("Error audio: " + e.message);
          }
        }

        if (text && AUDIO_BY_TEXT[text]) {
          try {
            await playPrerecordedAudio(AUDIO_BY_TEXT[text], []);
            resolve();
            return;
          } catch (e) {}
        }

        if (CONFIG.ELEVENLABS_API_KEY && text) {
          try {
            await speakWithElevenLabs(text);
            resolve();
            return;
          } catch (e) {
            log("ElevenLabs error: " + e.message);
            if (!CONFIG.USE_BROWSER_TTS_FALLBACK) {
              stopTalking();
              resolve();
              return;
            }
          }
        }

        if (!synth || !text) { resolve(); return; }

        synth.cancel();
        currentUtterance = new SpeechSynthesisUtterance(text);
        if (selectedVoice) currentUtterance.voice = selectedVoice;
        currentUtterance.lang = 'es-ES';

        currentUtterance.onstart = () => startTTSLipSync();
        currentUtterance.onend = () => { stopTalking(); resolve(); };
        currentUtterance.onerror = () => { stopTalking(); resolve(); };

        synth.speak(currentUtterance);
      });
    }

    // ===========================================
    // Audio Pregenerado con Timestamps de Pausa
    // ===========================================
    let prerecordedAudio = null;

    async function playPrerecordedAudio(audioUrl, pauseTimestamps = []) {
      return new Promise((resolve, reject) => {
        // Limpiar audio anterior completamente
        if (prerecordedAudio) {
          prerecordedAudio.onplay = null;
          prerecordedAudio.onended = null;
          prerecordedAudio.onerror = null;
          prerecordedAudio.pause();
          prerecordedAudio.src = '';
          prerecordedAudio = null;
        }

        prerecordedAudio = new Audio(audioUrl);
        
        // Usar once para evitar eventos duplicados
        prerecordedAudio.onplay = () => {
          log("▶ Audio reproduciendo");
          startLipSyncWithTimestamps(pauseTimestamps);
          // Iniciar sincronización de subtítulos karaoke
          startKaraokeSync();
        };

        prerecordedAudio.onended = () => { 
          log("⏹ Audio terminado");
          stopTalking();
          stopKaraokeSync();
          resolve(); 
        };
        
        prerecordedAudio.onerror = (e) => { 
          log("❌ Error audio: " + e.type);
          stopTalking(); 
          reject(new Error("Audio error")); 
        };
        
        prerecordedAudio.play().catch((e) => {
          log("❌ Error play: " + e.message);
          reject(e);
        });
      });
    }

    // ===========================================
    // ElevenLabs
    // ===========================================
    let elevenLabsAudio = null;

    async function speakWithElevenLabs(text) {
      log("ElevenLabs...");
      
      const response = await fetch(
        `https://api.elevenlabs.io/v1/text-to-speech/${CONFIG.ELEVENLABS_VOICE_ID}`,
        {
          method: "POST",
          headers: {
            "Accept": "audio/mpeg",
            "Content-Type": "application/json",
            "xi-api-key": CONFIG.ELEVENLABS_API_KEY,
          },
          body: JSON.stringify({
            text,
            model_id: CONFIG.ELEVENLABS_MODEL,
            voice_settings: { stability: 0.5, similarity_boost: 0.75 },
          }),
        }
      );

      if (!response.ok) throw new Error(`API ${response.status}`);

      const audioBlob = await response.blob();
      const audioUrl = URL.createObjectURL(audioBlob);

      return new Promise((resolve, reject) => {
        // Limpiar audio anterior completamente
        if (elevenLabsAudio) {
          elevenLabsAudio.onplay = null;
          elevenLabsAudio.onended = null;
          elevenLabsAudio.onerror = null;
          elevenLabsAudio.pause();
          elevenLabsAudio.src = '';
          elevenLabsAudio = null;
        }

        elevenLabsAudio = new Audio(audioUrl);
        elevenLabsAudio.onplay = () => startTTSLipSync();
        elevenLabsAudio.onended = () => { 
          stopTalking(); 
          URL.revokeObjectURL(audioUrl); 
          resolve(); 
        };
        elevenLabsAudio.onerror = () => { 
          stopTalking(); 
          URL.revokeObjectURL(audioUrl); 
          reject(); 
        };
        elevenLabsAudio.play().catch(reject);
      });
    }

    function stopSpeaking() {
      // Detener síntesis de voz
      if (synth) {
        synth.cancel();
      }
      
      // Detener y limpiar audio de ElevenLabs
      if (elevenLabsAudio) {
        elevenLabsAudio.pause();
        elevenLabsAudio.currentTime = 0;
        elevenLabsAudio.src = '';
        elevenLabsAudio = null;
      }
      
      // Detener y limpiar audio pregenerado
      if (prerecordedAudio) {
        prerecordedAudio.pause();
        prerecordedAudio.currentTime = 0;
        prerecordedAudio.src = '';
        prerecordedAudio = null;
      }
      
      stopTalking();
      hideSubtitle();
    }

    // ===========================================
    // RIVE
    // ===========================================
    let riveInstance = null;
    let hasRive = false;
    let isTalkingInput = null;
    let visemeIDInput = null;
    let visemeTimer = null;
    let ttsLipSyncTimer = null;

    async function initRive() {
      log("Cargando Rive...");
      setStatus("Cargando avatar...", "loading");

      const Rive = RiveCanvas.Rive || RiveCanvas.default || RiveCanvas;

      if (typeof Rive !== "function") {
        fallbackToCSS("No Rive");
        return;
      }

      try {
        riveInstance = new Rive({
          src: CONFIG.RIVE_FILE,
          canvas: riveCanvas,
          stateMachines: CONFIG.STATE_MACHINE,
          autoplay: true,
          onLoad: onRiveLoad,
          onLoadError: onRiveError
        });
      } catch (e) {
        fallbackToCSS(e.message);
      }
    }

    function onRiveLoad() {
      setTimeout(() => {
        try {
          const inputs = riveInstance.stateMachineInputs(CONFIG.STATE_MACHINE);
          
          if (!inputs || inputs.length === 0) {
            fallbackToCSS("Sin inputs");
            return;
          }
          
          inputs.forEach(input => {
            if (input.name === "isTalking") isTalkingInput = input;
            else if (input.name === "VisemeID") visemeIDInput = input;
          });

          if (isTalkingInput && visemeIDInput) {
            hasRive = true;
            riveWrap.style.display = "grid";
            cssAvatar.style.display = "none";
            setStatus("Avatar listo", "ok");
            log("✓ Rive OK");
          } else {
            fallbackToCSS("Inputs incompletos");
          }
        } catch (e) {
          fallbackToCSS(e.message);
        }
      }, 100);
    }

    function onRiveError(err) {
      fallbackToCSS(String(err));
    }

    function fallbackToCSS(reason) {
      hasRive = false;
      riveWrap.style.display = "none";
      cssAvatar.style.display = "grid";
      setStatus("CSS fallback", "error");
      log("Fallback: " + reason);
    }

    // ===========================================
    // Lip Sync
    // ===========================================
    function stopTalking() {
      if (visemeTimer) { clearInterval(visemeTimer); visemeTimer = null; }
      if (ttsLipSyncTimer) { clearInterval(ttsLipSyncTimer); ttsLipSyncTimer = null; }

      if (hasRive) {
        if (isTalkingInput) isTalkingInput.value = false;
        if (visemeIDInput) visemeIDInput.value = 0;
      }

      if (presentationIsTalkingInput) presentationIsTalkingInput.value = false;
      if (presentationVisemeIDInput) presentationVisemeIDInput.value = 0;

      cssSetMouthOpen(0);
    }

    // Lip sync simple sin pausas
    function startTTSLipSync() {
      if (!hasRive && !isPresentationMode) {
        startCSSFakeTalking(99999);
        return;
      }

      if (isPresentationMode && presentationIsTalkingInput) {
        presentationIsTalkingInput.value = true;
      } else if (isTalkingInput) {
        isTalkingInput.value = true;
      }

      const targetVisemeInput = isPresentationMode ? presentationVisemeIDInput : visemeIDInput;

      if (targetVisemeInput) {
        if (ttsLipSyncTimer) clearInterval(ttsLipSyncTimer);
        
        const visemes = [0, 1, 2, 3, 4, 5, 6, 7, 8];
        let lastViseme = 0;
        
        ttsLipSyncTimer = setInterval(() => {
          let newViseme;
          do {
            newViseme = visemes[Math.floor(Math.random() * visemes.length)];
          } while (newViseme === lastViseme);
          lastViseme = newViseme;
          targetVisemeInput.value = newViseme;
        }, 90);
      }
    }

    // ===========================================
    // Lip Sync con Timestamps Manuales
    // ===========================================
    function startLipSyncWithTimestamps(pauseTimestamps = []) {
      if (!hasRive && !isPresentationMode) {
        startCSSFakeTalking(99999);
        return;
      }

      const targetIsTalkingInput = isPresentationMode ? presentationIsTalkingInput : isTalkingInput;
      const targetVisemeInput = isPresentationMode ? presentationVisemeIDInput : visemeIDInput;

      // Si no hay pausas definidas, usar lip-sync normal
      if (!pauseTimestamps || pauseTimestamps.length === 0) {
        log("Sin pausas definidas, lip-sync continuo");
        startTTSLipSync();
        return;
      }

      log("Lip-sync con " + pauseTimestamps.length + " pausas: " + pauseTimestamps.join(", ") + " ms");

      if (targetIsTalkingInput) targetIsTalkingInput.value = true;

      if (targetVisemeInput) {
        if (ttsLipSyncTimer) clearInterval(ttsLipSyncTimer);
        
        const visemes = [0, 1, 2, 3, 4, 5, 6, 7, 8];
        let lastViseme = 0;
        const startTime = performance.now();
        const pauseDuration = CONFIG.PAUSE_DURATION;
        
        // Crear rangos de pausa [inicio, fin]
        const pauseRanges = pauseTimestamps.map(t => ({
          start: t,
          end: t + pauseDuration
        }));
        
        ttsLipSyncTimer = setInterval(() => {
          const elapsed = performance.now() - startTime;
          
          // Verificar si estamos dentro de algún rango de pausa
          const inPause = pauseRanges.some(range => 
            elapsed >= range.start && elapsed < range.end
          );
          
          if (inPause) {
            // Estamos en pausa - cerrar boca
            targetVisemeInput.value = 0;
            if (targetIsTalkingInput) targetIsTalkingInput.value = false;
            return;
          }
          
          // No estamos en pausa - animar labios
          if (targetIsTalkingInput && !targetIsTalkingInput.value) {
            targetIsTalkingInput.value = true;
          }
          
          let newViseme;
          do {
            newViseme = visemes[Math.floor(Math.random() * visemes.length)];
          } while (newViseme === lastViseme);
          lastViseme = newViseme;
          targetVisemeInput.value = newViseme;
        }, 90);
      }
    }

    function startCSSFakeTalking(durationMs) {
      const start = performance.now();
      const tick = () => {
        const elapsed = performance.now() - start;
        if (elapsed >= durationMs) { cssSetMouthOpen(0); return; }
        const wave = Math.sin(elapsed / 85);
        cssSetMouthOpen(0.45 + 0.55 * wave);
        requestAnimationFrame(tick);
      };
      requestAnimationFrame(tick);
    }

    // ===========================================
    // Controls
    // ===========================================
    $("idleBtn").onclick = () => {
      log("Detenido");
      stopSpeaking();
      bubbleEl.textContent = "En espera…";
    };

    $("testTalkBtn").onclick = async () => {
      const testText = "Hola, soy tu asistente virtual. ¿En qué puedo ayudarte?";
      bubbleEl.textContent = testText;
      if (isPresentationMode) showSubtitle(testText);
      log("Test TTS");
      await speak(testText);
    };

    // ===========================================
    // WebSocket
    // ===========================================
    const qp = new URLSearchParams(location.search);
    const BACKEND_HOST = qp.get("backend") || CONFIG.BACKEND_HOST;
    const wsProto = location.protocol === "https:" ? "wss://" : "ws://";
    let ws = null;
    let wsReconnectTimer = null;
    let currentAudioId = null;

    function connectWebSocket() {
      if (wsReconnectTimer) clearTimeout(wsReconnectTimer);
      
      try {
        log("WS: " + BACKEND_HOST);
        ws = new WebSocket(wsProto + BACKEND_HOST);

        ws.onopen = () => log("WS conectado ✓");
        ws.onclose = () => {
          log("WS cerrado");
          wsReconnectTimer = setTimeout(connectWebSocket, 5000);
        };
        ws.onerror = () => log("WS error");

        ws.onmessage = async (ev) => {
          let msg;
          try { msg = JSON.parse(ev.data); } catch { return; }

          log("WS: " + msg.type);

          if (msg.type === "bot_speaking_start") {
            const audioId = msg.audioId || msg.lineId || null;
            
            // ⚡ FILTRO: Solo procesar si el audioId está en AUDIO_BANK
            if (!audioId || !AUDIO_BANK[audioId]) {
              log("⏭️ Ignorando mensaje (no es audio pregenerado): " + audioId);
              return;
            }
            
            currentAudioId = audioId;
            
            // Si es intro_1 y estamos en presentación, mostrar avatar
            if (audioId === CONFIG.PRESENTATION_START_ID && isPresentationMode) {
              showPresentationAvatar();
              await new Promise(r => setTimeout(r, 1000));
            }
            
            const entry = AUDIO_BANK[audioId];
            
            bubbleEl.textContent = entry.text;
            if (isPresentationMode) showSubtitleKaraoke(entry.text, entry.pauses || []);

            // Reproducir audio pregenerado con timestamps
            if (msg.audioUrl) {
              try {
                await playPrerecordedAudio(msg.audioUrl, entry.pauses || []);
              } catch (e) {
                await speak(entry.text, audioId);
              }
            } else {
              await speak(entry.text, audioId);
            }
            
            // Si es despedida_1 y estamos en presentación, ocultar avatar
            if (audioId === CONFIG.PRESENTATION_END_ID && isPresentationMode) {
              hidePresentationAvatar();
            }
          }

          if (msg.type === "bot_speaking_end") {
            if (currentAudioId === CONFIG.PRESENTATION_END_ID && isPresentationMode) {
              hidePresentationAvatar();
            }
            stopSpeaking();
            currentAudioId = null;
          }
        };
      } catch (e) {
        log("WS error: " + e.message);
        wsReconnectTimer = setTimeout(connectWebSocket, 5000);
      }
    }

    // ===========================================
    // Fullscreen normal
    // ===========================================
    const fullscreenBtn = $("fullscreenBtn");
    let isFullscreen = false;

    fullscreenBtn.onclick = () => {
      isFullscreen = !isFullscreen;
      
      if (isFullscreen) {
        riveWrap.classList.add("fullscreen");
        fullscreenBtn.innerHTML = '<i data-lucide="minimize-2"></i>';
        lucide.createIcons();
        if (riveWrap.requestFullscreen) riveWrap.requestFullscreen().catch(() => {});
      } else {
        riveWrap.classList.remove("fullscreen");
        fullscreenBtn.innerHTML = '<i data-lucide="maximize-2"></i>';
        lucide.createIcons();
        if (document.exitFullscreen && document.fullscreenElement) document.exitFullscreen().catch(() => {});
      }
    };

    document.addEventListener("fullscreenchange", () => {
      if (!document.fullscreenElement && isFullscreen) {
        isFullscreen = false;
        riveWrap.classList.remove("fullscreen");
        fullscreenBtn.innerHTML = '<i data-lucide="maximize-2"></i>';
        lucide.createIcons();
      }
    });

    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        if (isPresentationMode) exitPresentationMode();
        else if (isFullscreen) {
          isFullscreen = false;
          riveWrap.classList.remove("fullscreen");
          fullscreenBtn.innerHTML = '<i data-lucide="maximize-2"></i>';
          lucide.createIcons();
        }
      }
    });

    // ===========================================
    // Init
    // ===========================================
    log("Iniciando...");
    await initRive();
    connectWebSocket();
    bubbleEl.textContent = "En espera…";
    lucide.createIcons();
  </script>
</body>

</html>