<!doctype html>
<html lang="es">

<head>
  <meta charset="utf-8" />
  <title>Gespropiedad Avatar Demo</title>
  <style>
    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: #0b0f14;
      color: #e6edf3;
      display: grid;
      place-items: center;
      height: 100vh;
    }

    .stage {
      width: min(980px, 94vw);
      height: min(560px, 88vh);
      background: #0f1621;
      border: 1px solid #1f2a3a;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, .35);
      display: grid;
      grid-template-columns: 1.1fr 1fr;
      gap: 24px;
      padding: 28px;
      align-items: center;
    }

    .avatar {
      display: grid;
      place-items: center;
      position: relative;
      min-height: 320px;
    }

    /* ---------- RIVE PRIMARY ---------- */
    .rive-wrap {
      width: 320px;
      height: 320px;
      display: grid;
      place-items: center;
      border-radius: 24px;
      background: radial-gradient(circle at 30% 30%, #1a2535, #0d121b 70%);
      border: 1px solid #223146;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03);
    }

    canvas#riveCanvas {
      width: 300px;
      height: 300px;
    }

    /* ---------- CSS FALLBACK AVATAR ---------- */
    .css-avatar {
      display: none;
      place-items: center;
    }

    .head {
      width: 260px;
      height: 260px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #2b3b52, #111823 70%);
      position: relative;
      border: 1px solid #243247;
      animation: breathe 5.5s ease-in-out infinite;
    }

    @keyframes breathe {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-2px); }
    }

    .eye {
      width: 26px;
      height: 26px;
      border-radius: 50%;
      background: #e6edf3;
      position: absolute;
      top: 90px;
      overflow: hidden;
    }

    .eye.left { left: 80px; }
    .eye.right { right: 80px; }

    .eye::after {
      content: "";
      position: absolute;
      inset: 0;
      background: #0f1621;
      transform: translateY(-120%);
      animation: blink 6s infinite;
      animation-timing-function: cubic-bezier(.2, .8, .2, 1);
    }

    .eye.right::after { animation-delay: .2s; }

    @keyframes blink {
      0%, 92%, 100% { transform: translateY(-120%); }
      94%, 96% { transform: translateY(0%); }
    }

    .pupil {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #0b0f14;
      position: absolute;
      top: 8px;
      left: 8px;
    }

    .mouth {
      width: 90px;
      height: 18px;
      background: #e6edf3;
      border-radius: 0 0 18px 18px;
      position: absolute;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%) scaleY(1);
      transform-origin: center top;
      transition: transform 40ms linear;
      overflow: hidden;
    }

    .mouth-inner {
      width: 100%;
      height: 100%;
      background: #0b0f14;
      opacity: 0.85;
    }

    /* ---------- PANEL ---------- */
    .panel {
      display: grid;
      gap: 14px;
    }

    .status {
      font-size: 14px;
      opacity: 0.8;
    }

    .debug {
      font-size: 12px;
      opacity: 0.6;
      font-family: monospace;
      max-height: 80px;
      overflow-y: auto;
      background: #080b10;
      padding: 8px;
      border-radius: 6px;
    }

    .bubble {
      background: #0b111b;
      border: 1px solid #1d2a3b;
      border-radius: 14px;
      padding: 16px 18px;
      min-height: 120px;
      font-size: 18px;
      line-height: 1.35;
    }

    .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    button {
      background: #1b2a3d;
      color: #e6edf3;
      border: 1px solid #2a3c54;
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
    }

    button:hover {
      filter: brightness(1.08);
    }

    button.active {
      background: #2a4a6d;
      border-color: #4a7ab0;
    }
  </style>
</head>

<body>
  <div class="stage">
    <div class="avatar">
      <!-- RIVE -->
      <div class="rive-wrap" id="riveWrap">
        <canvas id="riveCanvas" width="300" height="300"></canvas>
      </div>

      <!-- CSS FALLBACK -->
      <div class="css-avatar" id="cssAvatar">
        <div class="head">
          <div class="eye left">
            <div class="pupil"></div>
          </div>
          <div class="eye right">
            <div class="pupil"></div>
          </div>
          <div class="mouth" id="cssMouth">
            <div class="mouth-inner"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="status" id="status">Estado: inicializando...</div>
      <div class="debug" id="debug">Debug info...</div>
      <div class="bubble" id="bubble">Listo para recibir eventos del bot.</div>
      <div class="row">
        <button id="enableAudio">Activar audio</button>
        <button id="testTalk">Test hablar</button>
        <button id="idleBtn">Idle</button>
      </div>
      <audio id="ttsAudio" crossorigin="anonymous"></audio>
    </div>
  </div>

  <script type="module">
    // -----------------------------
    // DOM
    // -----------------------------
    const statusEl = document.getElementById("status");
    const debugEl = document.getElementById("debug");
    const bubbleEl = document.getElementById("bubble");
    const audioEl = document.getElementById("ttsAudio");
    const enableBtn = document.getElementById("enableAudio");
    const testTalkBtn = document.getElementById("testTalk");
    const idleBtn = document.getElementById("idleBtn");

    const riveWrap = document.getElementById("riveWrap");
    const riveCanvas = document.getElementById("riveCanvas");

    const cssAvatar = document.getElementById("cssAvatar");
    const cssMouth = document.getElementById("cssMouth");

    function log(msg) {
      console.log(msg);
      debugEl.textContent = msg + "\n" + debugEl.textContent;
    }

    // -----------------------------
    // CSS Fallback - Mouth control
    // -----------------------------
    function cssSetMouthOpen(value) {
      // value: 0 (cerrada) a 1 (abierta)
      const scale = 0.2 + (value * 0.8); // mínimo 0.2, máximo 1
      cssMouth.style.transform = `translateX(-50%) scaleY(${scale})`;
    }

    // -----------------------------
    // Audio Context
    // -----------------------------
    let audioCtx = null;
    let analyser = null;
    let sourceNode = null;
    let rafId = null;
    let fakeRaf = null;

    function ensureAudioGraph() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      sourceNode = audioCtx.createMediaElementSource(audioEl);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      sourceNode.connect(analyser);
      analyser.connect(audioCtx.destination);
    }

    enableBtn.addEventListener("click", async () => {
      try {
        ensureAudioGraph();
        await audioCtx.resume();
        statusEl.textContent = "Estado: audio activado ✓";
        log("AudioContext activado");
      } catch (e) {
        statusEl.textContent = "Estado: error activando audio";
        log("Error audio: " + e.message);
      }
    });

    // -----------------------------
    // RIVE - Asset del Marketplace
    // -----------------------------
    // Asset: https://rive.app/marketplace/22280-41736-avatar/
    // Este asset usa State Machine "Avatar" con inputs específicos
    
    const RIVE_FILE = "./avatar.riv";
    
    let rive = null;
    let hasRive = false;
    let riveInputs = {};

    async function initRive() {
      try {
        log("Cargando Rive runtime...");
        const { Rive } = await import("https://unpkg.com/@rive-app/canvas@2.21.0");

        log(`Cargando archivo: ${RIVE_FILE}`);
        
        rive = new Rive({
          src: RIVE_FILE,
          canvas: riveCanvas,
          autoplay: true,
          onLoad: () => {
            log("Rive onLoad triggered");
            
            // Listar todas las state machines disponibles
            const stateMachines = rive.stateMachineNames;
            log(`State Machines encontradas: ${JSON.stringify(stateMachines)}`);
            
            // Usar la primera state machine disponible
            if (stateMachines && stateMachines.length > 0) {
              const smName = stateMachines[0];
              log(`Usando State Machine: "${smName}"`);
              
              // Obtener inputs
              const inputs = rive.stateMachineInputs(smName) || [];
              log(`Inputs encontrados (${inputs.length}):`);
              
              inputs.forEach(input => {
                const info = `  - "${input.name}" (type: ${input.type})`;
                log(info);
                riveInputs[input.name] = input;
              });
              
              hasRive = true;
              riveWrap.style.display = "grid";
              cssAvatar.style.display = "none";
              statusEl.textContent = "Estado: Rive cargado ✓";
            } else {
              // Sin state machine, solo animación básica
              log("No hay State Machines, usando animación base");
              hasRive = true;
              riveWrap.style.display = "grid";
              cssAvatar.style.display = "none";
              statusEl.textContent = "Estado: Rive (sin SM)";
            }
          },
          onLoadError: (e) => {
            log(`Error cargando Rive: ${e}`);
            fallbackToCSS("Error de carga");
          }
        });

      } catch (e) {
        log(`Exception Rive: ${e.message}`);
        fallbackToCSS(e.message);
      }
    }

    function fallbackToCSS(reason) {
      hasRive = false;
      riveWrap.style.display = "none";
      cssAvatar.style.display = "grid";
      statusEl.textContent = `Estado: CSS fallback (${reason})`;
    }

    // -----------------------------
    // Control de habla - Rive
    // -----------------------------
    let visemeTimer = null;

    function setRiveInput(name, value) {
      if (riveInputs[name]) {
        riveInputs[name].value = value;
        return true;
      }
      // Buscar variantes comunes
      const variants = [
        name,
        name.toLowerCase(),
        name.charAt(0).toUpperCase() + name.slice(1),
      ];
      for (const v of variants) {
        if (riveInputs[v]) {
          riveInputs[v].value = value;
          return true;
        }
      }
      return false;
    }

    function getRiveInput(name) {
      if (riveInputs[name]) return riveInputs[name];
      // Buscar por nombre parcial
      for (const key of Object.keys(riveInputs)) {
        if (key.toLowerCase().includes(name.toLowerCase())) {
          return riveInputs[key];
        }
      }
      return null;
    }

    function stopRiveTalking() {
      if (visemeTimer) {
        clearInterval(visemeTimer);
        visemeTimer = null;
      }
      
      // Intentar con nombres comunes
      setRiveInput("isTalking", false);
      setRiveInput("talking", false);
      setRiveInput("Talking", false);
      setRiveInput("VisemeID", 0);
      setRiveInput("viseme", 0);
      setRiveInput("Viseme", 0);
      setRiveInput("mouthOpen", 0);
      setRiveInput("MouthOpen", 0);
    }

    function startRiveTalking(durationMs = 2000) {
      if (!hasRive) {
        startCSSFakeTalking(durationMs);
        return;
      }

      // Activar estado de habla
      const talkingSet = setRiveInput("isTalking", true) || 
                         setRiveInput("talking", true) ||
                         setRiveInput("Talking", true);
      
      if (talkingSet) {
        log("isTalking activado");
      }

      // Si hay input de visema, ciclarlo
      const visemeInput = getRiveInput("viseme") || getRiveInput("VisemeID");
      if (visemeInput) {
        log(`Ciclando visemas en: ${visemeInput.name}`);
        const VIS = [0, 1, 2, 3, 4, 5, 6, 7, 8];
        
        if (visemeTimer) clearInterval(visemeTimer);
        visemeTimer = setInterval(() => {
          visemeInput.value = VIS[Math.floor(Math.random() * VIS.length)];
        }, 90);
      }

      // También probar mouthOpen
      const mouthInput = getRiveInput("mouth") || getRiveInput("MouthOpen");
      if (mouthInput && !visemeInput) {
        log(`Usando mouthOpen: ${mouthInput.name}`);
        if (visemeTimer) clearInterval(visemeTimer);
        visemeTimer = setInterval(() => {
          mouthInput.value = Math.random();
        }, 80);
      }

      // Auto-stop
      setTimeout(() => stopRiveTalking(), durationMs + 100);
    }

    function applyAudioToRive(rms) {
      if (!hasRive) return false;

      // Activar talking
      setRiveInput("isTalking", true) || setRiveInput("talking", true);

      // Aplicar a visema o mouth
      const visemeInput = getRiveInput("viseme") || getRiveInput("VisemeID");
      if (visemeInput) {
        let id = 0;
        if (rms < 0.018) id = 0;
        else if (rms < 0.028) id = 1;
        else if (rms < 0.040) id = 3;
        else if (rms < 0.055) id = 5;
        else id = 7;
        visemeInput.value = id;
        return true;
      }

      const mouthInput = getRiveInput("mouth") || getRiveInput("MouthOpen");
      if (mouthInput) {
        mouthInput.value = Math.min(1, rms * 15);
        return true;
      }

      return false;
    }

    // -----------------------------
    // Control de habla - CSS Fallback
    // -----------------------------
    function startCSSFakeTalking(durationMs = 2000) {
      const start = performance.now();
      if (fakeRaf) cancelAnimationFrame(fakeRaf);

      const attackMs = 180;

      const tick = (t) => {
        const elapsed = t - start;
        const progress = Math.min(1, elapsed / durationMs);

        const wave = Math.sin(t / 85);
        const attack = Math.min(1, elapsed / attackMs);
        const decay = 1 - Math.max(0, (progress - 0.85) / 0.15);
        const envelope = Math.max(0, Math.min(1, attack * decay));

        const open = (0.45 + 0.55 * wave) * envelope;
        cssSetMouthOpen(open);

        if (elapsed < durationMs) {
          fakeRaf = requestAnimationFrame(tick);
        } else {
          cssSetMouthOpen(0);
          fakeRaf = null;
        }
      };

      fakeRaf = requestAnimationFrame(tick);
    }

    // -----------------------------
    // Lip-sync desde audio real
    // -----------------------------
    function startLipSyncFromAudio() {
      ensureAudioGraph();
      const data = new Uint8Array(analyser.fftSize);
      let smoothed = 0;

      const tick = () => {
        analyser.getByteTimeDomainData(data);

        let sum = 0;
        for (let i = 0; i < data.length; i++) {
          const v = (data[i] - 128) / 128;
          sum += v * v;
        }
        const rms = Math.sqrt(sum / data.length);

        const rawOpen = Math.min(1, Math.max(0, (rms - 0.015) * 12));
        smoothed = smoothed * 0.75 + rawOpen * 0.25;

        const usedRive = applyAudioToRive(rms);

        if (!usedRive) {
          cssSetMouthOpen(smoothed);
        }

        if (!audioEl.paused && !audioEl.ended) {
          rafId = requestAnimationFrame(tick);
        } else {
          if (rafId) cancelAnimationFrame(rafId);
          rafId = null;
          stopRiveTalking();
          cssSetMouthOpen(0);
        }
      };

      tick();
    }

    // -----------------------------
    // Control general
    // -----------------------------
    function setIdle() {
      if (fakeRaf) cancelAnimationFrame(fakeRaf);
      fakeRaf = null;

      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;

      bubbleEl.textContent = "En espera…";
      stopRiveTalking();
      cssSetMouthOpen(0);
    }

    audioEl.addEventListener("play", () => {
      log("Audio play");
      startLipSyncFromAudio();
    });

    audioEl.addEventListener("ended", () => {
      log("Audio ended");
      setIdle();
    });

    idleBtn.addEventListener("click", () => {
      log("Idle manual");
      setIdle();
    });

    testTalkBtn.addEventListener("click", () => {
      log("Test hablar 3s");
      bubbleEl.textContent = "Probando animación de habla...";
      startRiveTalking(3000);
    });

    // -----------------------------
    // WebSocket al Avatar Bridge
    // -----------------------------
    const qp = new URLSearchParams(location.search);
    const BACKEND_HOST = qp.get("backend") || "hogar-avatar-api.conexiatec.com";
    const wsProto = location.protocol === "https:" ? "wss://" : "ws://";
    
    let ws = null;
    
    function connectWebSocket() {
      try {
        ws = new WebSocket(`${wsProto}${BACKEND_HOST}`);

        ws.onopen = () => {
          statusEl.textContent = `Estado: conectado (${BACKEND_HOST})`;
          log(`WebSocket conectado: ${BACKEND_HOST}`);
        };
        
        ws.onclose = () => {
          log("WebSocket cerrado");
          setTimeout(connectWebSocket, 3000);
        };
        
        ws.onerror = (e) => {
          log("WebSocket error");
        };

        ws.onmessage = (ev) => {
          let msg;
          try { msg = JSON.parse(ev.data); } catch { return; }

          log(`WS msg: ${msg.type}`);

          if (msg.type === "bot_speaking_start") {
            if (msg.text) bubbleEl.textContent = msg.text;

            if (msg.audioUrl) {
              audioEl.src = msg.audioUrl;
              audioEl.currentTime = 0;
              audioEl.play().catch(() => {
                bubbleEl.textContent = "⚠️ Pulsa 'Activar audio' para permitir reproducción.";
              });
            } else {
              const duration = msg.durationMs ?? 2000;
              startRiveTalking(duration);
            }
          }

          if (msg.type === "bot_speaking_end") {
            audioEl.pause();
            setIdle();
          }
        };
      } catch (e) {
        log(`WS exception: ${e.message}`);
      }
    }

    // -----------------------------
    // Init
    // -----------------------------
    await initRive();
    
    // Esperar un momento para que Rive cargue completamente
    setTimeout(() => {
      connectWebSocket();
      setIdle();
    }, 500);
  </script>
</body>

</html>