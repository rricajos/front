<!doctype html>
<html lang="es">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gespropiedad Avatar</title>
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
  <style>
    :root {
      --brand-primary: #1ca4af;
      --brand-secondary: #1c3768;
      --bg-dark: #0b0f14;
      --bg-card: #0f1621;
      --bg-input: #0a0e14;
      --border-color: #1f2a3a;
      --border-light: #2a3c54;
      --text-primary: #e6edf3;
      --text-muted: rgba(230, 237, 243, 0.6);
      --success: #22c55e;
      --error: #ef4444;
      --warning: #eab308;
    }

    * { box-sizing: border-box; }
    
    body {
      margin: 0;
      font-family: system-ui, -apple-system, sans-serif;
      background: linear-gradient(135deg, var(--bg-dark) 0%, #1a1f2e 100%);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }

    .start-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, #0b0f14 0%, #131a24 50%, #0d1117 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      gap: 20px;
      padding: 24px;
    }

    .start-overlay.hidden { display: none; }

    .start-logo {
      width: 100px;
      height: auto;
      opacity: 0.9;
    }

    .start-overlay h1 {
      font-size: 1.6rem;
      margin: 0;
      color: #fff;
      font-weight: 600;
      letter-spacing: -0.02em;
      text-align: center;
    }

    .start-overlay p {
      font-size: 0.95rem;
      color: var(--text-muted);
      margin: 0;
      text-align: center;
      max-width: 320px;
      line-height: 1.5;
    }

    .start-buttons {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 12px;
      width: 100%;
      max-width: 300px;
    }

    .start-btn {
      background: linear-gradient(135deg, var(--brand-primary) 0%, var(--brand-secondary) 100%);
      color: white;
      border: none;
      padding: 14px 28px;
      font-size: 0.95rem;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.25s ease;
      box-shadow: 0 4px 20px rgba(28, 164, 175, 0.25);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      width: 100%;
    }

    .start-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 28px rgba(28, 164, 175, 0.35); }
    .start-btn:active { transform: translateY(0); }

    .start-btn.secondary {
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      box-shadow: none;
    }

    .start-btn.secondary:hover { background: rgba(255, 255, 255, 0.12); box-shadow: none; }
    .start-btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none !important; }
    .start-btn i { width: 18px; height: 18px; flex-shrink: 0; }

    body.presentation-mode { background: #000; padding: 0; }
    body.presentation-mode .stage { display: none; }

    .presentation-container {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: #000;
      z-index: 9999;
      align-items: center;
      justify-content: center;
    }

    body.presentation-mode .presentation-container { display: flex; }

    .presentation-avatar {
      opacity: 0;
      transform: scale(0.92);
      transition: opacity 1.8s ease-out, transform 1.8s ease-out;
      position: relative;
    }

    .presentation-avatar.visible { opacity: 1; transform: scale(1); }
    .presentation-avatar.fading-out { opacity: 0; transform: scale(0.92); transition: opacity 2.5s ease-in, transform 2.5s ease-in; }

    .presentation-avatar .pres-rive-wrap {
      width: 100vmin; height: 100vmin;
      max-width: 700px; max-height: 700px;
      display: grid;
      place-items: center;
    }

    .presentation-avatar #presentationCanvas { width: 100%; height: 100%; }

    .presentation-container::before {
      content: "";
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      width: 105vh; height: 105vh;
      opacity: 0;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 226.1 219.1'%3E%3Cdefs%3E%3ClinearGradient id='a' x1='56' y1='178.7' x2='56' y2='0' gradientUnits='userSpaceOnUse'%3E%3Cstop offset='0' stop-color='%231ca4af'/%3E%3Cstop offset='1' stop-color='%231c3768'/%3E%3C/linearGradient%3E%3ClinearGradient id='b' x1='139.2' y1='53.5' x2='232.6' y2='215.2' href='%23a'/%3E%3C/defs%3E%3Cpolygon fill='url(%23a)' points='0 0 73.6 111 26.2 178.7 65.6 178.7 111.9 109.9 41.8 0 0 0'/%3E%3Cpolygon fill='url(%23b)' points='194.6 45.6 150.2 111 226 219 186.7 219 111.9 109.9 152.9 45.6 194.6 45.6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: center;
      background-size: contain;
      pointer-events: none;
      z-index: 0;
      transition: opacity 1.8s ease-out;
    }

    .presentation-container.show-logo::before { opacity: 0.33; }

    .presentation-subtitle {
      position: fixed;
      bottom: 4%; left: 50%;
      transform: translateX(-50%);
      width: auto; max-width: 85%;
      text-align: center;
      font-size: clamp(1rem, 1.8vw, 1.25rem);
      line-height: 1.5;
      color: #fff;
      text-shadow: 0 0 20px rgba(28, 164, 175, 0.5), 0 2px 12px rgba(0, 0, 0, 0.9);
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 10001;
      padding: 16px 32px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 12px;
      backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .presentation-subtitle.visible { opacity: 1; }

    .presentation-logo {
      position: fixed;
      bottom: 24px; left: 24px;
      height: 80px; width: auto;
      opacity: 0;
      transition: opacity 1.5s ease-out;
      z-index: 10001;
      filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.4));
      border-radius: 10px;
    }

    .presentation-container.show-logo .presentation-logo { opacity: 0.9; }
    .presentation-avatar.fading-out ~ .presentation-logo { opacity: 0; transition: opacity 2s ease-in; }

    .exit-presentation-btn {
      position: fixed;
      top: 20px; right: 20px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.12);
      color: white;
      width: 44px; height: 44px;
      border-radius: 50%;
      cursor: pointer;
      z-index: 10002;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.3s, background 0.2s;
    }

    .exit-presentation-btn:hover { background: rgba(255, 255, 255, 0.15); opacity: 1 !important; }
    .exit-presentation-btn:disabled { display: none; }
    .exit-presentation-btn i { width: 20px; height: 20px; }
    .presentation-container:hover .exit-presentation-btn:not(:disabled) { opacity: 0.4; }

    .stage {
      width: 100%; max-width: 900px;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, .35);
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
      padding: 28px;
      align-items: center;
    }

    @media (max-width: 800px) {
      .stage { grid-template-columns: 1fr; gap: 20px; padding: 20px; }
      .avatar { order: 1; }
      .panel { order: 2; }
    }

    @media (max-width: 480px) {
      body { padding: 8px; }
      .stage { border-radius: 16px; padding: 16px; gap: 16px; }
      .rive-wrap { width: 220px !important; height: 220px !important; }
      #riveCanvas { width: 200px !important; height: 200px !important; }
      .bubble { min-height: 70px !important; font-size: 15px !important; }
      .btn-row { flex-direction: column; }
      .btn { width: 100%; }
    }

    .avatar { display: flex; justify-content: center; align-items: center; min-height: 260px; position: relative; }

    .rive-wrap {
      width: 280px; height: 280px;
      display: grid;
      place-items: center;
      border-radius: 20px;
      background: radial-gradient(circle at 30% 30%, #1a2535, #0d121b 70%);
      border: 1px solid #223146;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03), 0 8px 32px rgba(0, 0, 0, 0.3);
      overflow: hidden;
      position: relative;
    }

    #riveCanvas { width: 260px; height: 260px; }
    .css-avatar { display: none; place-items: center; }

    .head {
      width: 180px; height: 180px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #2b3b52, #111823 70%);
      position: relative;
      border: 1px solid #243247;
      animation: breathe 5.5s ease-in-out infinite;
    }

    @keyframes breathe { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-2px); } }

    .eye { width: 20px; height: 20px; border-radius: 50%; background: var(--text-primary); position: absolute; top: 65px; overflow: hidden; }
    .eye.left { left: 55px; }
    .eye.right { right: 55px; }
    .eye::after { content: ""; position: absolute; inset: 0; background: var(--bg-card); transform: translateY(-120%); animation: blink 6s infinite; }
    @keyframes blink { 0%, 92%, 100% { transform: translateY(-120%); } 94%, 96% { transform: translateY(0%); } }
    .pupil { width: 7px; height: 7px; border-radius: 50%; background: var(--bg-dark); position: absolute; top: 6px; left: 6px; }

    .mouth {
      width: 60px; height: 12px;
      background: var(--text-primary);
      border-radius: 0 0 12px 12px;
      position: absolute;
      bottom: 50px; left: 50%;
      transform: translateX(-50%) scaleY(0.2);
      transform-origin: center top;
      transition: transform 40ms linear;
    }

    .panel { display: flex; flex-direction: column; gap: 14px; }

    .status-bar {
      display: flex; align-items: center; gap: 10px;
      padding: 10px 14px;
      background: var(--bg-input);
      border-radius: 10px;
      border: 1px solid var(--border-color);
    }

    .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #666; flex-shrink: 0; }
    .status-dot.ok { background: var(--success); }
    .status-dot.error { background: var(--error); }
    .status-dot.loading { background: var(--warning); animation: pulse 1s infinite; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
    .status-text { font-size: 13px; color: var(--text-muted); flex: 1; }

    .debug {
      font-size: 10px; color: var(--text-muted);
      font-family: 'SF Mono', Monaco, Consolas, monospace;
      max-height: 60px; overflow-y: auto;
      background: var(--bg-input);
      padding: 10px 12px;
      border-radius: 8px;
      white-space: pre-wrap;
      word-break: break-all;
      line-height: 1.4;
      border: 1px solid var(--border-color);
    }

    .bubble {
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 14px 16px;
      min-height: 90px; max-height: 130px;
      overflow-y: auto;
      font-size: 15px;
      line-height: 1.5;
      color: var(--text-primary);
    }

    .btn-row { display: flex; gap: 10px; }

    .btn {
      background: rgba(255, 255, 255, 0.06);
      color: var(--text-primary);
      border: 1px solid var(--border-light);
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 500;
      font-size: 13px;
      transition: all 0.15s;
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .btn:hover { background: rgba(255, 255, 255, 0.1); border-color: rgba(255, 255, 255, 0.2); }
    .btn:active { transform: scale(0.97); }
    .btn i { width: 16px; height: 16px; flex-shrink: 0; }
    .btn.primary { background: linear-gradient(135deg, var(--brand-primary) 0%, var(--brand-secondary) 100%); border: none; box-shadow: 0 2px 12px rgba(28, 164, 175, 0.2); }
    .btn.primary:hover { box-shadow: 0 4px 16px rgba(28, 164, 175, 0.3); }
    .btn:disabled { opacity: 0.4; cursor: not-allowed; }

    .settings-section { background: var(--bg-input); border-radius: 10px; padding: 12px 14px; border: 1px solid var(--border-color); }
    .settings-section label { font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-muted); display: flex; align-items: center; gap: 6px; margin-bottom: 8px; }
    .settings-section label i { width: 14px; height: 14px; }
    .voice-select { background: var(--bg-dark); color: var(--text-primary); border: 1px solid var(--border-color); padding: 8px 10px; border-radius: 8px; font-size: 13px; width: 100%; }
    .voice-select:focus { outline: none; border-color: var(--brand-primary); }

    .fullscreen-btn {
      position: absolute; top: 8px; right: 8px;
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.1);
      width: 32px; height: 32px; padding: 0;
      border-radius: 8px;
      cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      opacity: 0;
      transition: opacity 0.2s, background 0.2s;
      color: white;
    }

    .fullscreen-btn i { width: 16px; height: 16px; }
    .rive-wrap:hover .fullscreen-btn { opacity: 0.7; }
    .fullscreen-btn:hover { opacity: 1 !important; background: rgba(0, 0, 0, 0.6); }

    .rive-wrap.fullscreen {
      position: fixed !important;
      top: 0 !important; left: 0 !important;
      width: 100vw !important; height: 100vh !important;
      max-width: none !important;
      border-radius: 0 !important;
      z-index: 9999;
      background: #000;
    }

    .rive-wrap.fullscreen #riveCanvas { width: 100vmin !important; height: 100vmin !important; }
    .rive-wrap.fullscreen .fullscreen-btn { top: 16px; right: 16px; width: 40px; height: 40px; opacity: 0.5; }
  </style>
</head>

<body>
  <div class="start-overlay" id="startOverlay">
    <svg class="start-logo" viewBox="0 0 226.1 219.1" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <linearGradient id="grad1" x1="56" y1="178.7" x2="56" y2="0" gradientUnits="userSpaceOnUse">
          <stop offset="0" stop-color="#1ca4af"/>
          <stop offset="1" stop-color="#1c3768"/>
        </linearGradient>
        <linearGradient id="grad2" x1="139.2" y1="53.5" x2="232.6" y2="215.2" gradientUnits="userSpaceOnUse">
          <stop offset="0" stop-color="#1ca4af"/>
          <stop offset="1" stop-color="#1c3768"/>
        </linearGradient>
      </defs>
      <polygon fill="url(#grad1)" points="0 0 73.6 111 26.2 178.7 65.6 178.7 111.9 109.9 41.8 0 0 0"/>
      <polygon fill="url(#grad2)" points="194.6 45.6 150.2 111 226 219 186.7 219 111.9 109.9 152.9 45.6 194.6 45.6"/>
    </svg>
    <h1>Asistente Virtual</h1>
    <p>Conexia Telecom Â· Gestpropiedad</p>
    <div class="start-buttons">
      <button class="start-btn" id="startPresentationBtn">
        <i data-lucide="tv"></i>
        Modo PresentaciÃ³n
      </button>
      <button class="start-btn secondary" id="startNormalBtn" disabled>
        <i data-lucide="settings-2"></i>
        Panel de Control
      </button>
    </div>
  </div>

  <div class="presentation-container" id="presentationContainer">
    <button class="exit-presentation-btn" id="exitPresentationBtn" title="Salir (ESC)" disabled>
      <i data-lucide="x"></i>
    </button>
    <div class="presentation-avatar" id="presentationAvatar">
      <div class="pres-rive-wrap">
        <canvas id="presentationCanvas" width="800" height="800"></canvas>
      </div>
    </div>
    <img src="./gestpropiedad.jpg" alt="GestPropiedad" class="presentation-logo">
    <div class="presentation-subtitle" id="presentationSubtitle"></div>
  </div>

  <div class="stage">
    <div class="avatar">
      <div class="rive-wrap" id="riveWrap">
        <button class="fullscreen-btn" id="fullscreenBtn" title="Pantalla completa">
          <i data-lucide="maximize-2"></i>
        </button>
        <canvas id="riveCanvas" width="600" height="600"></canvas>
      </div>
      <div class="css-avatar" id="cssAvatar">
        <div class="head">
          <div class="eye left"><div class="pupil"></div></div>
          <div class="eye right"><div class="pupil"></div></div>
          <div class="mouth" id="cssMouth"></div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="status-bar">
        <span class="status-dot loading" id="statusDot"></span>
        <span class="status-text" id="statusText">Inicializando...</span>
      </div>
      <div class="debug" id="debug"></div>
      <div class="bubble" id="bubble">Listo para recibir eventos.</div>
      <div class="btn-row">
        <button class="btn primary" id="testTalkBtn"><i data-lucide="play"></i>Test</button>
        <button class="btn" id="idleBtn"><i data-lucide="pause"></i>Detener</button>
      </div>
      <div class="btn-row">
        <button class="btn primary" id="enterPresentationBtn"><i data-lucide="tv"></i>Modo PresentaciÃ³n</button>
      </div>
      <div class="settings-section">
        <label><i data-lucide="volume-2"></i>Voz TTS</label>
        <select id="voiceSelect" class="voice-select"><option value="">Cargando voces...</option></select>
      </div>
    </div>
  </div>

  <script type="module">
    const CONFIG = {
      ELEVENLABS_API_KEY: "sk_ed00c8630aeb0240abba435c3f0a4afcd6794a79c0d1aba6",
      ELEVENLABS_VOICE_ID: "uU1QvfOppdkePeLtG9pI",
      ELEVENLABS_MODEL: "eleven_multilingual_v2",
      BACKEND_HOST: "hogar-avatar-api.conexiatec.com",
      RIVE_FILE: "./avatar.riv",
      STATE_MACHINE: "State Machine",
      USE_BROWSER_TTS_FALLBACK: true,
      PRESENTATION_START_ID: "intro_1",
      PRESENTATION_END_ID: "despedida_1",
      PAUSE_DURATION: 500,
    };

    const AUDIO_BANK = {
      "intro_1": {
        text: "Hola a todos. Perdonad mi entradaâ€¦ estaba esperando. Y he pensado: 'igual os habÃ­ais olvidado de mÃ­'.",
        audio: "./audio/intro_1.mp3",
        segments: [
          { text: "Hola a todos.", start: 0 },
          { text: "Perdonad mi entradaâ€¦ estaba esperando.", start: 1331 },
          { text: "Y he pensado: 'igual os habÃ­ais olvidado de mÃ­'.", start: 3074 },
        ],
        pauses: [771, 2240]
      },
      "que_es_1": {
        text: "Buenas noches a todos. Y sÃ­, es cierto: no duermoâ€¦ no pido vacacionesâ€¦ y los lunes no me afectan. Pero prometo ser simpÃ¡tica igualmente. Me presento: soy la nueva IA de Gestpropiedad. Vengo a echar una mano en tres frentes. Primero, con los clientes. Cuando la oficina cierre, me quedo de guardia para que ningÃºn cliente se quede sin respuesta. Segundo, en la web. AyudarÃ© a entender mejor cada vivienda y a guiar a cada cliente hasta el asesor correcto. Y tercero, el mÃ¡s importante: vosotros. Os ayudarÃ© a encontrar la informaciÃ³n que necesitÃ©is en segundos, y a responder con mÃ¡s claridadâ€¦ sin quitaros vuestro estilo.",
        audio: "./audio/que_es_1.mp3",
        segments: [
          { text: "Buenas noches a todos.", start: 0 },
          { text: "Y sÃ­, es cierto: no duermoâ€¦ no pido vacacionesâ€¦ y los lunes no me afectan.", start: 1802 },
          { text: "Pero prometo ser simpÃ¡tica igualmente.", start: 7806 },
          { text: "Me presento: soy la nueva IA de Gestpropiedad.", start: 11148 },
          { text: "Vengo a echar una mano en tres frentes.", start: 15476 },
          { text: "Primero, con los clientes.", start: 18818 },
          { text: "Cuando la oficina cierre, me quedo de guardia para que ningÃºn cliente se quede sin respuesta.", start: 20500 },
          { text: "Segundo, en la web.", start: 29701 },
          { text: "AyudarÃ© a entender mejor cada vivienda y a guiar a cada cliente hasta el asesor correcto.", start: 31500 },
          { text: "Y tercero, el mÃ¡s importante: vosotros.", start: 36753 },
          { text: "Os ayudarÃ© a encontrar la informaciÃ³n que necesitÃ©is en segundos, y a responder con mÃ¡s claridadâ€¦ sin quitaros vuestro estilo.", start: 38701 },
        ],
        pauses: [1052, 4771, 5573, 6908, 10257, 12593, 24400, 29027, 33460]
      },
      "aprendizaje_1": {
        text: "No es todo, esto es solo el principio. Hoy es, literalmente, mi nacimiento. A partir de ahora irÃ© aprendiendo cada dÃ­a: de las consultasâ€¦ de cÃ³mo trabajÃ¡isâ€¦ de lo que necesitan los clientesâ€¦ y de los datos que me ha proporcionado el equipo. Cuanto mÃ¡s se me use, mejor podrÃ© ayudarâ€¦ y en mÃ¡s Ã¡mbitos. Prometo crecer rÃ¡pidoâ€¦ y sin adolescencia rebelde.",
        audio: "./audio/aprendizaje_1.mp3",
        segments: [
          { text: "No es todo, esto es solo el principio.", start: 0 },
          { text: "Hoy es, literalmente, mi nacimiento.", start: 2490 },
          { text: "A partir de ahora irÃ© aprendiendo cada dÃ­a:", start: 6319 },
          { text: "de las consultasâ€¦ de cÃ³mo trabajÃ¡isâ€¦ de lo que necesitan los clientesâ€¦ y de los datos que me ha proporcionado el equipo.", start: 9503 },
          { text: "Cuanto mÃ¡s se me use, mejor podrÃ© ayudarâ€¦ y en mÃ¡s Ã¡mbitos.", start: 17495 },
          { text: "Prometo crecer rÃ¡pidoâ€¦ y sin adolescencia rebelde.", start: 23070 },
        ],
        pauses: [1805, 3058, 5441, 8556, 11417, 13869, 16530, 18731, 21164, 22497]
      },
      "despedida_1": {
        text: "Exacto. No tengo nombre. De momento soy 'la IA de Gestpropiedad'â€¦ y suena frÃ­o, poco personal... Como vamos a trabajar juntos, me gustarÃ­a que fuerais vosotros, mi equipo, quienes elijÃ¡is mi nombre esta noche. Yo me despido aquÃ­ y os dejo con Alejandro para que os explique las opciones. Para cuando vuelvaâ€¦ ya serÃ¡ con mi nombre oficial. Y tranquilos: ninguna opciÃ³n es 'ChatPaco' ni 'BotManolo'... â€¦de eso podÃ©is estar seguros... Ha sido un placer saludaros por primera vez. Gracias, y nos vemos muy pronto.",
        audio: "./audio/despedida_1.mp3",
        segments: [
          { text: "Exacto. No tengo nombre.", start: 0 },
          { text: "De momento soy 'la IA de Gestpropiedad'â€¦ y suena frÃ­o, poco personal...", start: 5190 },
          { text: "Como vamos a trabajar juntos, me gustarÃ­a que fuerais vosotros, mi equipo, quienes elijÃ¡is mi nombre esta noche.", start: 8186 },
          { text: "Yo me despido aquÃ­ y os dejo con Alejandro para que os explique las opciones.", start: 13324 },
          { text: "Para cuando vuelvaâ€¦ ya serÃ¡ con mi nombre oficial.", start: 20232 },
          { text: "Y tranquilos: ninguna opciÃ³n es 'ChatPaco' ni 'BotManolo'... â€¦de eso podÃ©is estar seguros...", start: 23913 },
          { text: "Ha sido un placer saludaros por primera vez.", start: 30828 },
          { text: "Gracias, y nos vemos muy pronto.", start: 33692 },
        ],
        pauses: [641, 1258, 4561, 5924, 7047, 9895, 17543, 19494, 21069, 24548, 27297, 28749, 30249]
      },
    };

    const AUDIO_BY_TEXT = {};

    import RiveCanvas from "https://cdn.jsdelivr.net/npm/@rive-app/canvas@2.21.6/+esm";

    const $ = id => document.getElementById(id);
    const statusDot = $("statusDot");
    const statusText = $("statusText");
    const debugEl = $("debug");
    const bubbleEl = $("bubble");
    const riveWrap = $("riveWrap");
    const riveCanvas = $("riveCanvas");
    const cssAvatar = $("cssAvatar");
    const cssMouth = $("cssMouth");
    const voiceSelect = $("voiceSelect");
    const startOverlay = $("startOverlay");
    const startNormalBtn = $("startNormalBtn");
    const startPresentationBtn = $("startPresentationBtn");
    const presentationContainer = $("presentationContainer");
    const presentationAvatar = $("presentationAvatar");
    const presentationCanvas = $("presentationCanvas");
    const presentationSubtitle = $("presentationSubtitle");
    const exitPresentationBtn = $("exitPresentationBtn");
    const enterPresentationBtn = $("enterPresentationBtn");

    let isPresentationMode = false;
    let presentationRiveInstance = null;
    let presentationIsTalkingInput = null;
    let presentationVisemeIDInput = null;

    function setStatus(text, state = "loading") {
      statusText.textContent = text;
      statusDot.className = "status-dot " + state;
    }

    function log(msg) {
      console.log("[Avatar]", msg);
      const time = new Date().toLocaleTimeString("es", { hour12: false });
      debugEl.textContent = `[${time}] ${msg}\n` + debugEl.textContent.slice(0, 400);
    }

    async function unlockAudio() {
      try {
        const silentAudio = new Audio("data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2teleCAHQJnx+aCFNgRDmvz/mXoxBEaZ/P+YdywFR5r8/5d3KgZIm/z/lnkpB0mc/P+VeigISp38/5R7JwlLnfz/k3wmCkye/P+SfSULTZ/8/5F+JAxOoPz/kH8jDU+h/P+PgCIOUKL8/46BIQ9Ro/z/jYIfEFKk/P+MgyAQU6X8/4uEHxFUpvz/ioUeElWn/P+Jhh0TV6j8/4iHHBRYqfz/h4gcFVqq/P+GiRsWW6v8/4WKGhdcrPz/hIoZGF2t/P+DixgZXq78/4KMGB5fr/z/gY0XH2Cw/P+AjhYgYbH8/3+PFSFisfz/fpAUI2Oz/P99kRMkZLT8/3ySEiVltfz/e5MSJGW1");
        silentAudio.volume = 0.01;
        await silentAudio.play();
        silentAudio.pause();
        if (synth) { const u = new SpeechSynthesisUtterance(""); u.volume = 0; synth.speak(u); synth.cancel(); }
        log("Audio OK âœ“");
        return true;
      } catch (e) { log("Audio error: " + e.message); return false; }
    }

    startNormalBtn.onclick = async () => { /* Deshabilitado */ };
    startPresentationBtn.onclick = async () => {
      await unlockAudio();
      startOverlay.classList.add("hidden");
      await enterPresentationMode();
    };

    async function enterPresentationMode() {
      log("â†’ Modo presentaciÃ³n");
      isPresentationMode = true;
      document.body.classList.add("presentation-mode");
      if (!presentationRiveInstance) await initPresentationRive();
      presentationAvatar.classList.remove("visible", "fading-out");
      presentationSubtitle.classList.remove("visible");
      presentationSubtitle.textContent = "";
    }

    function exitPresentationMode() { /* Deshabilitado */ }

    function showPresentationAvatar() {
      log("âœ¨ Avatar apareciendo");
      presentationContainer.classList.add("show-logo");
      presentationAvatar.classList.remove("fading-out");
      presentationAvatar.classList.add("visible");
    }

    function hidePresentationAvatar() {
      log("âœ¨ Avatar desapareciendo");
      presentationAvatar.classList.add("fading-out");
      presentationSubtitle.classList.remove("visible");
      setTimeout(() => {
        presentationContainer.classList.remove("show-logo");
        presentationAvatar.classList.remove("visible", "fading-out");
      }, 3000);
    }

    function showSubtitle(text) {
      if (!isPresentationMode) return;
      presentationSubtitle.textContent = text;
      presentationSubtitle.classList.add("visible");
    }

    function hideSubtitle() {
      stopKaraokeSync();
      presentationSubtitle.classList.remove("visible");
    }

    let karaokeTimer = null;
    let karaokeSegments = [];
    let karaokeStartTime = 0;

    function showSubtitleKaraoke(entry) {
      if (!isPresentationMode) return;
      stopKaraokeSync();
      karaokeSegments = (entry.segments && entry.segments.length > 0) ? entry.segments : [{ text: entry.text, start: 0 }];
    }

    function startKaraokeSync() {
      if (karaokeSegments.length === 0) return;
      karaokeStartTime = performance.now();
      let currentIndex = 0;
      presentationSubtitle.textContent = karaokeSegments[0].text;
      presentationSubtitle.classList.add("visible");
      log("â–¶ Karaoke: " + karaokeSegments.length + " segmentos");
      karaokeTimer = setInterval(() => {
        const elapsed = performance.now() - karaokeStartTime;
        let newIndex = 0;
        for (let i = 0; i < karaokeSegments.length; i++) {
          if (elapsed >= karaokeSegments[i].start) newIndex = i;
        }
        if (newIndex !== currentIndex) {
          currentIndex = newIndex;
          presentationSubtitle.textContent = karaokeSegments[currentIndex].text;
        }
      }, 50);
    }

    function stopKaraokeSync() {
      if (karaokeTimer) { clearInterval(karaokeTimer); karaokeTimer = null; }
      karaokeSegments = [];
      presentationSubtitle.textContent = '';
    }

    async function initPresentationRive() {
      log("Cargando Rive (presentaciÃ³n)...");
      const Rive = RiveCanvas.Rive || RiveCanvas.default || RiveCanvas;
      return new Promise((resolve) => {
        try {
          presentationRiveInstance = new Rive({
            src: CONFIG.RIVE_FILE,
            canvas: presentationCanvas,
            stateMachines: CONFIG.STATE_MACHINE,
            autoplay: true,
            onLoad: () => {
              setTimeout(() => {
                try {
                  const inputs = presentationRiveInstance.stateMachineInputs(CONFIG.STATE_MACHINE);
                  log("Rive inputs encontrados: " + (inputs ? inputs.length : 0));
                  if (inputs && inputs.length > 0) {
                    inputs.forEach(input => {
                      log("  â†’ Input: " + input.name);
                      if (input.name === "isTalking") {
                        presentationIsTalkingInput = input;
                        log("  âœ“ isTalking asignado");
                      }
                      else if (input.name === "VisemeID") {
                        presentationVisemeIDInput = input;
                        log("  âœ“ VisemeID asignado");
                      }
                    });
                    log("âœ“ Rive presentaciÃ³n OK - talking:" + !!presentationIsTalkingInput + " viseme:" + !!presentationVisemeIDInput);
                  } else {
                    log("âš ï¸ No se encontraron inputs en Rive");
                  }
                  resolve();
                } catch (e) { log("Error inputs: " + e.message); resolve(); }
              }, 150);
            },
            onLoadError: (err) => { log("Error Rive: " + err); resolve(); }
          });
        } catch (e) { log("Error Rive: " + e.message); resolve(); }
      });
    }

    exitPresentationBtn.onclick = exitPresentationMode;
    enterPresentationBtn.onclick = enterPresentationMode;

    function cssSetMouthOpen(value) {
      const scale = 0.2 + (value * 0.8);
      cssMouth.style.transform = `translateX(-50%) scaleY(${scale})`;
    }

    let synth = window.speechSynthesis;
    let voices = [];
    let selectedVoice = null;
    let currentUtterance = null;
    let voicesLoaded = false;
    
    function loadVoices() {
      voices = synth.getVoices();
      if (voices.length === 0) return;
      const filteredVoices = voices.filter(v => !v.name.toLowerCase().includes('microsoft'));
      const spanishVoices = filteredVoices.filter(v => v.lang.startsWith('es'));
      const otherVoices = filteredVoices.filter(v => !v.lang.startsWith('es'));
      const sortedVoices = [...spanishVoices, ...otherVoices];
      if (voicesLoaded && voiceSelect.options.length === sortedVoices.length) return;
      voicesLoaded = true;
      voiceSelect.innerHTML = '';
      if (sortedVoices.length === 0) { voiceSelect.innerHTML = '<option value="">Sin voces</option>'; return; }
      sortedVoices.forEach((voice, i) => {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `${voice.name} (${voice.lang})`;
        if (voice.lang.startsWith('es') && !selectedVoice) { option.selected = true; selectedVoice = voice; }
        voiceSelect.appendChild(option);
      });
      if (!selectedVoice && sortedVoices.length > 0) { selectedVoice = sortedVoices[0]; voiceSelect.selectedIndex = 0; }
      log("Voces: " + sortedVoices.length);
    }

    if (synth.onvoiceschanged !== undefined) synth.onvoiceschanged = loadVoices;
    loadVoices();

    voiceSelect.addEventListener('change', () => {
      const allVoices = synth.getVoices();
      const filteredVoices = allVoices.filter(v => !v.name.toLowerCase().includes('microsoft'));
      const spanishVoices = filteredVoices.filter(v => v.lang.startsWith('es'));
      const otherVoices = filteredVoices.filter(v => !v.lang.startsWith('es'));
      const sortedVoices = [...spanishVoices, ...otherVoices];
      selectedVoice = sortedVoices[voiceSelect.value] || null;
    });

    function speak(text, audioId = null) {
      return new Promise(async (resolve) => {
        if (!text && !audioId) { resolve(); return; }

        log("ðŸ—£ï¸ speak() llamado - audioId:" + audioId);
        
        // Solo detener audio, NO limpiar timers de lip-sync
        stopAudioOnly();

        if (audioId && AUDIO_BANK[audioId]) {
          const entry = AUDIO_BANK[audioId];
          log("ðŸŽµ Usando AUDIO_BANK: " + audioId + " (" + entry.pauses.length + " pausas)");
          bubbleEl.textContent = entry.text;
          if (isPresentationMode) showSubtitleKaraoke(entry);
          try {
            await playPrerecordedAudio(entry.audio, entry.pauses || []);
            log("âœ… Audio completado: " + audioId);
            resolve();
            return;
          } catch (e) { log("Error audio: " + e.message); }
        }

        if (text && AUDIO_BY_TEXT[text]) {
          try { await playPrerecordedAudio(AUDIO_BY_TEXT[text], []); resolve(); return; } catch (e) {}
        }

        if (CONFIG.ELEVENLABS_API_KEY && text) {
          try { await speakWithElevenLabs(text); resolve(); return; }
          catch (e) { log("ElevenLabs error: " + e.message); if (!CONFIG.USE_BROWSER_TTS_FALLBACK) { stopTalking(); resolve(); return; } }
        }

        if (!synth || !text) { resolve(); return; }
        synth.cancel();
        currentUtterance = new SpeechSynthesisUtterance(text);
        if (selectedVoice) currentUtterance.voice = selectedVoice;
        currentUtterance.lang = 'es-ES';
        currentUtterance.onstart = () => startLipSyncWithTimestamps([]);
        currentUtterance.onend = () => { stopTalking(); resolve(); };
        currentUtterance.onerror = () => { stopTalking(); resolve(); };
        synth.speak(currentUtterance);
      });
    }

    let prerecordedAudio = null;
    let currentPauseTimestamps = [];

    async function playPrerecordedAudio(audioUrl, pauseTimestamps = []) {
      return new Promise((resolve, reject) => {
        const audioName = audioUrl.split('/').pop();
        log("ðŸ“€ Preparando: " + audioName);
        
        // Guardar pausas ANTES de cualquier otra cosa
        currentPauseTimestamps = pauseTimestamps.slice();
        
        // Limpiar audio anterior completamente
        if (prerecordedAudio) {
          try {
            prerecordedAudio.pause();
            prerecordedAudio.removeAttribute('src');
            prerecordedAudio.load();
          } catch(e) {}
          prerecordedAudio = null;
        }

        // Crear nuevo audio
        const audio = new Audio();
        prerecordedAudio = audio;
        
        // Usar addEventListener para mejor control
        const onPlay = () => {
          log("â–¶ PLAY: " + audioName);
          log("ðŸ” Inputs: isTalking=" + !!presentationIsTalkingInput + ", viseme=" + !!presentationVisemeIDInput);
          startLipSyncWithTimestamps(currentPauseTimestamps);
          startKaraokeSync();
        };
        
        const onEnded = () => {
          log("â¹ ENDED: " + audioName);
          audio.removeEventListener('play', onPlay);
          audio.removeEventListener('ended', onEnded);
          audio.removeEventListener('error', onError);
          stopTalking();
          stopKaraokeSync();
          resolve();
        };
        
        const onError = (e) => {
          log("âŒ ERROR: " + audioName);
          audio.removeEventListener('play', onPlay);
          audio.removeEventListener('ended', onEnded);
          audio.removeEventListener('error', onError);
          stopTalking();
          reject(new Error("Audio error"));
        };
        
        audio.addEventListener('play', onPlay);
        audio.addEventListener('ended', onEnded);
        audio.addEventListener('error', onError);
        
        // Cargar y reproducir
        audio.src = audioUrl;
        audio.play().then(() => {
          log("âœ“ play() OK: " + audioName);
        }).catch((e) => {
          log("âŒ play() FAIL: " + e.message);
          reject(e);
        });
      });
    }

    let elevenLabsAudio = null;

    async function speakWithElevenLabs(text) {
      log("ElevenLabs...");
      const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${CONFIG.ELEVENLABS_VOICE_ID}`, {
        method: "POST",
        headers: { "Accept": "audio/mpeg", "Content-Type": "application/json", "xi-api-key": CONFIG.ELEVENLABS_API_KEY },
        body: JSON.stringify({ text, model_id: CONFIG.ELEVENLABS_MODEL, voice_settings: { stability: 0.5, similarity_boost: 0.75 } }),
      });
      if (!response.ok) throw new Error(`API ${response.status}`);
      const audioBlob = await response.blob();
      const audioUrl = URL.createObjectURL(audioBlob);
      return new Promise((resolve, reject) => {
        if (elevenLabsAudio) { elevenLabsAudio.onplay = null; elevenLabsAudio.onended = null; elevenLabsAudio.onerror = null; elevenLabsAudio.pause(); elevenLabsAudio.src = ''; elevenLabsAudio = null; }
        elevenLabsAudio = new Audio(audioUrl);
        elevenLabsAudio.onplay = () => startLipSyncWithTimestamps([]);
        elevenLabsAudio.onended = () => { stopTalking(); URL.revokeObjectURL(audioUrl); resolve(); };
        elevenLabsAudio.onerror = () => { stopTalking(); URL.revokeObjectURL(audioUrl); reject(); };
        elevenLabsAudio.play().catch(reject);
      });
    }

    function stopAudioOnly() {
      log("ðŸ›‘ stopAudioOnly");
      if (synth) synth.cancel();
      if (elevenLabsAudio) { 
        elevenLabsAudio.pause(); 
        elevenLabsAudio = null; 
      }
      if (prerecordedAudio) { 
        prerecordedAudio.pause();
        prerecordedAudio = null; 
      }
    }

    function stopSpeaking() {
      stopAudioOnly();
      stopTalking();
      hideSubtitle();
    }

    let riveInstance = null;
    let hasRive = false;
    let isTalkingInput = null;
    let visemeIDInput = null;
    let visemeTimer = null;
    let ttsLipSyncTimer = null;

    async function initRive() {
      log("Cargando Rive...");
      setStatus("Cargando avatar...", "loading");
      const Rive = RiveCanvas.Rive || RiveCanvas.default || RiveCanvas;
      if (typeof Rive !== "function") { fallbackToCSS("No Rive"); return; }
      try {
        riveInstance = new Rive({
          src: CONFIG.RIVE_FILE,
          canvas: riveCanvas,
          stateMachines: CONFIG.STATE_MACHINE,
          autoplay: true,
          onLoad: onRiveLoad,
          onLoadError: onRiveError
        });
      } catch (e) { fallbackToCSS(e.message); }
    }

    function onRiveLoad() {
      setTimeout(() => {
        try {
          const inputs = riveInstance.stateMachineInputs(CONFIG.STATE_MACHINE);
          if (!inputs || inputs.length === 0) { fallbackToCSS("Sin inputs"); return; }
          inputs.forEach(input => {
            if (input.name === "isTalking") isTalkingInput = input;
            else if (input.name === "VisemeID") visemeIDInput = input;
          });
          if (isTalkingInput && visemeIDInput) {
            hasRive = true;
            riveWrap.style.display = "grid";
            cssAvatar.style.display = "none";
            setStatus("Avatar listo", "ok");
            log("âœ“ Rive OK");
          } else { fallbackToCSS("Inputs incompletos"); }
        } catch (e) { fallbackToCSS(e.message); }
      }, 100);
    }

    function onRiveError(err) { fallbackToCSS(String(err)); }

    function fallbackToCSS(reason) {
      hasRive = false;
      riveWrap.style.display = "none";
      cssAvatar.style.display = "grid";
      setStatus("CSS fallback", "error");
      log("Fallback: " + reason);
    }

    function stopTalking() {
      if (visemeTimer) { clearInterval(visemeTimer); visemeTimer = null; }
      if (ttsLipSyncTimer) { clearInterval(ttsLipSyncTimer); ttsLipSyncTimer = null; }
      if (hasRive) { if (isTalkingInput) isTalkingInput.value = false; if (visemeIDInput) visemeIDInput.value = 0; }
      if (presentationIsTalkingInput) presentationIsTalkingInput.value = false;
      if (presentationVisemeIDInput) presentationVisemeIDInput.value = 0;
      cssSetMouthOpen(0);
    }

    function startLipSyncWithTimestamps(pauseTimestamps = []) {
      // SIEMPRE limpiar timer anterior primero
      if (ttsLipSyncTimer) { 
        clearInterval(ttsLipSyncTimer); 
        ttsLipSyncTimer = null; 
        log("ðŸ§¹ Timer anterior limpiado");
      }

      // Determinar quÃ© inputs usar
      const targetIsTalkingInput = isPresentationMode ? presentationIsTalkingInput : isTalkingInput;
      const targetVisemeInput = isPresentationMode ? presentationVisemeIDInput : visemeIDInput;

      log("ðŸŽ¤ startLipSync - mode:" + (isPresentationMode ? "PRES" : "NORMAL") + 
          " talking:" + !!targetIsTalkingInput + 
          " viseme:" + !!targetVisemeInput + 
          " pausas:" + pauseTimestamps.length);

      // Verificar que tenemos los inputs necesarios
      if (!targetVisemeInput) {
        log("âš ï¸ NO HAY VISEME INPUT - lip-sync imposible");
        if (!hasRive && !isPresentationMode) {
          startCSSFakeTalking(99999);
        }
        return;
      }

      // Activar talking
      if (targetIsTalkingInput) {
        targetIsTalkingInput.value = true;
        log("âœ“ isTalking = true");
      }

      // Si no hay pausas, lip-sync continuo
      if (!pauseTimestamps || pauseTimestamps.length === 0) {
        log("â†’ Lip-sync continuo (sin pausas)");
        const visemes = [0, 1, 2, 3, 4, 5, 6, 7, 8];
        let lastViseme = 0;
        ttsLipSyncTimer = setInterval(() => {
          let newViseme;
          do { newViseme = visemes[Math.floor(Math.random() * visemes.length)]; } while (newViseme === lastViseme);
          lastViseme = newViseme;
          targetVisemeInput.value = newViseme;
        }, 90);
        log("âœ“ Timer continuo iniciado");
        return;
      }

      // Lip-sync con pausas
      log("â†’ Lip-sync con " + pauseTimestamps.length + " pausas");
      const visemes = [0, 1, 2, 3, 4, 5, 6, 7, 8];
      let lastViseme = 0;
      const startTime = performance.now();
      const pauseDuration = CONFIG.PAUSE_DURATION;
      const pauseRanges = pauseTimestamps.map(t => ({ start: t, end: t + pauseDuration }));
      
      ttsLipSyncTimer = setInterval(() => {
        const elapsed = performance.now() - startTime;
        const inPause = pauseRanges.some(range => elapsed >= range.start && elapsed < range.end);
        
        if (inPause) {
          targetVisemeInput.value = 0;
          if (targetIsTalkingInput) targetIsTalkingInput.value = false;
          return;
        }
        
        if (targetIsTalkingInput && !targetIsTalkingInput.value) targetIsTalkingInput.value = true;
        
        let newViseme;
        do { newViseme = visemes[Math.floor(Math.random() * visemes.length)]; } while (newViseme === lastViseme);
        lastViseme = newViseme;
        targetVisemeInput.value = newViseme;
      }, 90);
      
      log("âœ“ Timer con pausas iniciado");
    }

    function startCSSFakeTalking(durationMs) {
      const start = performance.now();
      const tick = () => {
        const elapsed = performance.now() - start;
        if (elapsed >= durationMs) { cssSetMouthOpen(0); return; }
        const wave = Math.sin(elapsed / 85);
        cssSetMouthOpen(0.45 + 0.55 * wave);
        requestAnimationFrame(tick);
      };
      requestAnimationFrame(tick);
    }

    $("idleBtn").onclick = () => { log("Detenido"); stopSpeaking(); bubbleEl.textContent = "En esperaâ€¦"; };
    $("testTalkBtn").onclick = async () => {
      const testText = "Hola, soy tu asistente virtual. Â¿En quÃ© puedo ayudarte?";
      bubbleEl.textContent = testText;
      if (isPresentationMode) showSubtitle(testText);
      log("Test TTS");
      await speak(testText);
    };

    const qp = new URLSearchParams(location.search);
    const BACKEND_HOST = qp.get("backend") || CONFIG.BACKEND_HOST;
    const wsProto = location.protocol === "https:" ? "wss://" : "ws://";
    let ws = null;
    let wsReconnectTimer = null;
    let currentAudioId = null;

    function connectWebSocket() {
      if (wsReconnectTimer) clearTimeout(wsReconnectTimer);
      try {
        log("WS: " + BACKEND_HOST);
        ws = new WebSocket(wsProto + BACKEND_HOST);
        ws.onopen = () => log("WS conectado âœ“");
        ws.onclose = () => { log("WS cerrado"); wsReconnectTimer = setTimeout(connectWebSocket, 5000); };
        ws.onerror = () => log("WS error");
        ws.onmessage = async (ev) => {
          let msg;
          try { msg = JSON.parse(ev.data); } catch { return; }
          log("WS: " + msg.type + (msg.audioId ? " [" + msg.audioId + "]" : ""));
          if (msg.type === "bot_speaking_start") {
            const audioId = msg.audioId || msg.lineId || null;
            if (!audioId || !AUDIO_BANK[audioId]) { log("â­ï¸ Ignorando: " + audioId); return; }
            currentAudioId = audioId;
            log("ðŸŽ¬ Procesando: " + audioId);
            if (audioId === CONFIG.PRESENTATION_START_ID && isPresentationMode) {
              showPresentationAvatar();
              await new Promise(r => setTimeout(r, 800));
            }
            await speak(null, audioId);
            log("ðŸŽ¬ Completado: " + audioId);
            if (audioId === CONFIG.PRESENTATION_END_ID && isPresentationMode) hidePresentationAvatar();
          }
          if (msg.type === "bot_speaking_end") {
            log("ðŸ›‘ bot_speaking_end recibido");
            if (currentAudioId === CONFIG.PRESENTATION_END_ID && isPresentationMode) hidePresentationAvatar();
            stopSpeaking();
            currentAudioId = null;
          }
        };
      } catch (e) { log("WS error: " + e.message); wsReconnectTimer = setTimeout(connectWebSocket, 5000); }
    }

    const fullscreenBtn = $("fullscreenBtn");
    let isFullscreen = false;

    fullscreenBtn.onclick = () => {
      isFullscreen = !isFullscreen;
      if (isFullscreen) {
        riveWrap.classList.add("fullscreen");
        fullscreenBtn.innerHTML = '<i data-lucide="minimize-2"></i>';
        lucide.createIcons();
        if (riveWrap.requestFullscreen) riveWrap.requestFullscreen().catch(() => {});
      } else {
        riveWrap.classList.remove("fullscreen");
        fullscreenBtn.innerHTML = '<i data-lucide="maximize-2"></i>';
        lucide.createIcons();
        if (document.exitFullscreen && document.fullscreenElement) document.exitFullscreen().catch(() => {});
      }
    };

    document.addEventListener("fullscreenchange", () => {
      if (!document.fullscreenElement && isFullscreen) {
        isFullscreen = false;
        riveWrap.classList.remove("fullscreen");
        fullscreenBtn.innerHTML = '<i data-lucide="maximize-2"></i>';
        lucide.createIcons();
      }
    });

    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && !isPresentationMode && isFullscreen) {
        isFullscreen = false;
        riveWrap.classList.remove("fullscreen");
        fullscreenBtn.innerHTML = '<i data-lucide="maximize-2"></i>';
        lucide.createIcons();
      }
    });

    log("Iniciando...");
    await initRive();
    connectWebSocket();
    bubbleEl.textContent = "En esperaâ€¦";
    lucide.createIcons();
  </script>
</body>
</html>