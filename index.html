<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Gespropiedad Avatar Demo</title>
  <style>
    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: #0b0f14;
      color: #e6edf3;
      display: grid;
      place-items: center;
      height: 100vh;
    }

    .stage {
      width: min(980px, 94vw);
      height: min(560px, 88vh);
      background: #0f1621;
      border: 1px solid #1f2a3a;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, .35);
      display: grid;
      grid-template-columns: 1.1fr 1fr;
      gap: 24px;
      padding: 28px;
      align-items: center;
    }

    .avatar {
      display: grid;
      place-items: center;
    }

    /* ---------- RIVE ---------- */
    .rive-wrap {
      width: 320px;
      height: 320px;
      display: grid;
      place-items: center;
      border-radius: 24px;
      background: radial-gradient(circle at 30% 30%, #1a2535, #0d121b 70%);
      border: 1px solid #223146;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03);
    }

    canvas#riveCanvas {
      width: 300px;
      height: 300px;
    }

    /* ---------- CSS FALLBACK AVATAR ---------- */
    .css-avatar {
      display: none; /* se mostrará solo si Rive falla */
    }

    .head {
      width: 260px;
      height: 260px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #2b3b52, #111823 70%);
      position: relative;
      border: 1px solid #243247;
      animation: breathe 5.5s ease-in-out infinite;
    }

    @keyframes breathe {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-2px); }
    }

    .eye {
      width: 26px;
      height: 26px;
      border-radius: 50%;
      background: #e6edf3;
      position: absolute;
      top: 90px;
      overflow: hidden;
    }

    .eye.left { left: 80px; }
    .eye.right { right: 80px; }

    .eye::after {
      content: "";
      position: absolute;
      inset: 0;
      background: #0f1621;
      transform: translateY(-120%);
      animation: blink 6s infinite;
      animation-timing-function: cubic-bezier(.2,.8,.2,1);
    }
    .eye.right::after { animation-delay: .2s; }

    @keyframes blink {
      0%, 92%, 100% { transform: translateY(-120%); }
      94%, 96% { transform: translateY(0%); }
    }

    .pupil {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #0b0f14;
      position: absolute;
      top: 8px;
      left: 8px;
    }

    .mouth {
      width: 90px;
      height: 18px;
      background: #e6edf3;
      border-radius: 0 0 18px 18px;
      position: absolute;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%) scaleY(1);
      transform-origin: center top;
      transition: transform 40ms linear;
      overflow: hidden;
    }

    .mouth-inner {
      width: 100%;
      height: 100%;
      background: #0b0f14;
      opacity: 0.85;
    }

    /* ---------- PANEL ---------- */
    .panel {
      display: grid;
      gap: 14px;
    }

    .status {
      font-size: 14px;
      opacity: 0.8;
    }

    .bubble {
      background: #0b111b;
      border: 1px solid #1d2a3b;
      border-radius: 14px;
      padding: 16px 18px;
      min-height: 160px;
      font-size: 18px;
      line-height: 1.35;
    }

    .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    button {
      background: #1b2a3d;
      color: #e6edf3;
      border: 1px solid #2a3c54;
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
    }

    button:hover { filter: brightness(1.08); }
  </style>
</head>

<body>
  <div class="stage">
    <div class="avatar">

      <!-- RIVE PRIMARY -->
      <div class="rive-wrap" id="riveWrap">
        <canvas id="riveCanvas" width="300" height="300"></canvas>
      </div>

      <!-- CSS FALLBACK -->
      <div class="css-avatar" id="cssAvatar">
        <div class="head">
          <div class="eye left"><div class="pupil"></div></div>
          <div class="eye right"><div class="pupil"></div></div>
          <div class="mouth"><div class="mouth-inner"></div></div>
        </div>
      </div>

    </div>

    <div class="panel">
      <div class="status" id="status">Estado: desconectado</div>
      <div class="bubble" id="bubble">Listo para recibir eventos del bot.</div>
      <div class="row">
        <button id="enableAudio">Activar audio</button>
        <button id="idleBtn">Idle</button>
      </div>
      <audio id="ttsAudio" crossorigin="anonymous"></audio>
    </div>
  </div>

  <script type="module">
    // -----------------------------
    // DOM
    // -----------------------------
    const statusEl = document.getElementById("status");
    const bubbleEl = document.getElementById("bubble");
    const audioEl = document.getElementById("ttsAudio");
    const enableBtn = document.getElementById("enableAudio");
    const idleBtn = document.getElementById("idleBtn");

    const riveWrap = document.getElementById("riveWrap");
    const riveCanvas = document.getElementById("riveCanvas");

    const cssAvatar = document.getElementById("cssAvatar");
    const mouthEl = cssAvatar.querySelector(".mouth");

    // -----------------------------
    // Audio graph
    // -----------------------------
    let audioCtx = null;
    let analyser = null;
    let sourceNode = null;
    let rafId = null;
    let fakeRaf = null;

    function ensureAudioGraph() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      sourceNode = audioCtx.createMediaElementSource(audioEl);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      sourceNode.connect(analyser);
      analyser.connect(audioCtx.destination);
    }

    enableBtn.addEventListener("click", async () => {
      try {
        ensureAudioGraph();
        await audioCtx.resume();
        statusEl.textContent = "Estado: audio activado";
        bubbleEl.textContent = "Listo para recibir eventos del bot.";
      } catch {
        statusEl.textContent = "Estado: error activando audio";
      }
    });

    // -----------------------------
    // RIVE setup (primary avatar)
    // -----------------------------
    let rive = null;
    let mouthInput = null;
    let hasRive = false;

    async function initRive() {
      try {
        const { Rive } = await import("https://unpkg.com/@rive-app/canvas@latest");

        rive = new Rive({
          src: "./avatar.riv",
          canvas: riveCanvas,
          autoplay: true,
          // Si tu archivo usa state machine, pon su nombre aquí:
          // stateMachines: "AvatarSM",
          // Si no sabes el nombre aún, deja esto sin definir y luego lo ajustas.
        });

        // Espera un frame para que cargue
        await new Promise(r => setTimeout(r, 50));

        // Si tienes state machine, intenta leer inputs:
        // const smName = "AvatarSM";
        // const inputs = rive.stateMachineInputs(smName) || [];
        // mouthInput = inputs.find(i => i.name === "MouthOpen");

        // Si NO tienes state machine listo todavía,
        // este front usará fallback CSS automáticamente.
        if (mouthInput) {
          hasRive = true;
          cssAvatar.style.display = "none";
        } else {
          // Mantén Rive visible si quieres aunque no tenga input de boca:
          // pero para lip-sync mejor fallback claro.
          throw new Error("MouthOpen input not found");
        }
      } catch (e) {
        // Fallback a CSS
        hasRive = false;
        riveWrap.style.display = "none";
        cssAvatar.style.display = "grid";
      }
    }

    // Llama init
    initRive();

    // -----------------------------
    // Mouth control abstraction
    // -----------------------------
    function setMouthOpen(value01) {
      const v = Math.max(0, Math.min(1, value01));

      if (hasRive && mouthInput) {
        mouthInput.value = v;
        return;
      }

      // CSS fallback
      const scaleY = 1 + v * 2.0;
      mouthEl.style.transform = `translateX(-50%) scaleY(${scaleY.toFixed(3)})`;
    }

    // -----------------------------
    // Idle / fake lip-sync
    // -----------------------------
    function setIdle() {
      if (fakeRaf) cancelAnimationFrame(fakeRaf);
      fakeRaf = null;

      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;

      bubbleEl.textContent = "En espera…";
      setMouthOpen(0);
    }

    function startFakeLipSync(durationMs = 2000) {
      const start = performance.now();
      if (fakeRaf) cancelAnimationFrame(fakeRaf);

      const attackMs = 180;

      const tick = (t) => {
        const elapsed = t - start;
        const progress = Math.min(1, elapsed / durationMs);

        const wave = Math.sin(t / 85);

        const attack = Math.min(1, elapsed / attackMs);
        const decay = 1 - Math.max(0, (progress - 0.85) / 0.15);
        const envelope = Math.max(0, Math.min(1, attack * decay));

        const open = (0.45 + 0.55 * wave) * envelope;
        setMouthOpen(open);

        if (elapsed < durationMs) {
          fakeRaf = requestAnimationFrame(tick);
        } else {
          setMouthOpen(0);
          fakeRaf = null;
        }
      };

      fakeRaf = requestAnimationFrame(tick);
    }

    // -----------------------------
    // Audio lip-sync (if audioUrl)
    // -----------------------------
    function startLipSyncFromAudio() {
      ensureAudioGraph();
      const data = new Uint8Array(analyser.fftSize);

      let smoothed = 0;

      const tick = () => {
        analyser.getByteTimeDomainData(data);

        let sum = 0;
        for (let i = 0; i < data.length; i++) {
          const v = (data[i] - 128) / 128;
          sum += v * v;
        }
        const rms = Math.sqrt(sum / data.length);

        const rawOpen = Math.min(1, Math.max(0, (rms - 0.015) * 12));
        smoothed = smoothed * 0.75 + rawOpen * 0.25;

        setMouthOpen(smoothed);

        if (!audioEl.paused && !audioEl.ended) {
          rafId = requestAnimationFrame(tick);
        } else {
          if (rafId) cancelAnimationFrame(rafId);
          rafId = null;
          setMouthOpen(0);
        }
      };

      tick();
    }

    audioEl.addEventListener("play", () => {
      startLipSyncFromAudio();
    });

    audioEl.addEventListener("ended", () => {
      setIdle();
    });

    idleBtn.addEventListener("click", setIdle);

    // -----------------------------
    // WebSocket (production-ready)
    // -----------------------------
    const qp = new URLSearchParams(location.search);
    const BACKEND_HOST = qp.get("backend") || "hogar-avatar-api.conexiatec.com";
    const wsProto = location.protocol === "https:" ? "wss://" : "ws://";
    const ws = new WebSocket(`${wsProto}${BACKEND_HOST}`);

    ws.onopen = () => {
      statusEl.textContent = `Estado: conectado al bridge (${BACKEND_HOST})`;
    };
    ws.onclose = () => {
      statusEl.textContent = "Estado: desconectado";
    };
    ws.onerror = () => {
      statusEl.textContent = "Estado: error WebSocket";
    };

    ws.onmessage = (ev) => {
      let msg;
      try { msg = JSON.parse(ev.data); } catch { return; }

      if (msg.type === "bot_speaking_start") {
        if (msg.text) bubbleEl.textContent = msg.text;

        if (msg.audioUrl) {
          audioEl.src = msg.audioUrl;
          audioEl.currentTime = 0;

          audioEl.play().catch(() => {
            bubbleEl.textContent = "⚠️ Pulsa “Activar audio” para permitir reproducción.";
          });
        } else {
          const duration = msg.durationMs ?? 2000;
          startFakeLipSync(duration);
        }
      }

      if (msg.type === "bot_speaking_end") {
        audioEl.pause();
        setIdle();
      }
    };

    setIdle();
  </script>
</body>
</html>
